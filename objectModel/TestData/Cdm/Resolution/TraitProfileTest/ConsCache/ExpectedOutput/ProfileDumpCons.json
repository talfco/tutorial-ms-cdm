{"Contact":{"entityProfile":[
  {
    "traitName": "commerce.individualCustomer",
    "explanation": "a party in the role of customer who purchase or uses products",
    "IS_A": {
      "traitName": "commerce.customer",
      "explanation": "a party in the role of customer who purchase or uses products",
      "IS_A": {
        "traitName": "commerce.party",
        "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
        "references": {
          "traitName": "commerce.party",
          "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
          "metaTraits": [
            {
              "traitName": "options.oneOf",
              "verb": {
                "traitName": "contains",
                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
              },
              "metaTraits": [
                {
                  "traitName": "commerce.individual",
                  "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                  "IS_A": {
                    "traitName": "person",
                    "references": {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName",
                              "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                              "IS_A": {
                                "traitName": "identity.completeName",
                                "IS_A": {
                                  "traitName": "identity.name",
                                  "explanation": "the words by which something is known or called",
                                  "IS_A": {
                                    "traitName": "means.identity",
                                    "explanation": "some form of identifying information"
                                  }
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "identity.identityKind",
                                    "IS_A": {
                                      "traitName": "kindOf",
                                      "IS_A": {
                                        "traitName": "means",
                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information",
                                          "verb": {
                                            "traitName": "of",
                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                          }
                                        },
                                        {
                                          "traitName": "explains.application",
                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                          "verb": {
                                            "traitName": "qualifiedBy",
                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                          }
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person"
                                      }
                                    ]
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.initials",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.firstName",
                                      "explanation": "A person's given or first name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.middleName",
                                      "explanation": "A person's middle name",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.prefix",
                                      "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastNamePrefix",
                                      "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastName",
                                      "explanation": "A person's surname, family name or last name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.suffix",
                                      "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    "metaTraits": [
                      {
                        "traitName": "businessProcess",
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                },
                {
                  "traitName": "organization.entity",
                  "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                }
              ]
            }
          ]
        },
        "metaTraits": [
          {
            "traitName": "action.purchase",
            "explanation": "the act of purchasing",
            "verb": {
              "traitName": "does",
              "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "commerce.product",
                "explanation": "an item and/or service (IS A oneOf[item, service])",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                },
                "metaTraits": [
                  {
                    "traitName": "options.oneOf",
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    },
                    "metaTraits": [
                      {
                        "traitName": "commerce.item",
                        "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      },
                      {
                        "traitName": "commerce.service",
                        "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      "metaTraits": [
        {
          "traitName": "commerce.partyKind.individual",
          "explanation": "indicates a individual party",
          "IS_A": {
            "traitName": "commerce.partyKind",
            "explanation": "a type indicator for kinds of parties",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "commerce.party",
                  "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "options.oneOf",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "commerce.individual",
                          "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                          "IS_A": {
                            "traitName": "person",
                            "references": {
                              "traitName": "person",
                              "verb": {
                                "traitName": "means",
                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.fullName",
                                      "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                      "IS_A": {
                                        "traitName": "identity.completeName",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "explanation": "the words by which something is known or called",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          }
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "contains",
                                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "options.anyOf",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person.initials",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.firstName",
                                              "explanation": "A person's given or first name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.middleName",
                                              "explanation": "A person's middle name",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.prefix",
                                              "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastNamePrefix",
                                              "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastName",
                                              "explanation": "A person's surname, family name or last name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.suffix",
                                              "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "traitName": "person.title",
                                      "explanation": "A personal or professional title",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.age",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.birthDate",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.ethnicity",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            "metaTraits": [
                              {
                                "traitName": "businessProcess",
                                "verb": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                }
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        },
                        {
                          "traitName": "organization.entity",
                          "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        }
                      ]
                    }
                  ]
                },
                {
                  "traitName": "explains.entity",
                  "explanation": "explaining that one concept or type indicator gives the 'type of thing' for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "metaTraits": [
              {
                "traitName": "commerce.individual",
                "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                "IS_A": {
                  "traitName": "person",
                  "references": {
                    "traitName": "person",
                    "metaTraits": [
                      {
                        "traitName": "options.anyOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "person.fullName",
                            "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                            "IS_A": {
                              "traitName": "identity.completeName",
                              "IS_A": {
                                "traitName": "identity.name",
                                "explanation": "the words by which something is known or called",
                                "IS_A": {
                                  "traitName": "means.identity",
                                  "explanation": "some form of identifying information"
                                }
                              },
                              "metaTraits": [
                                {
                                  "traitName": "identity.identityKind",
                                  "IS_A": {
                                    "traitName": "kindOf",
                                    "IS_A": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information",
                                        "verb": {
                                          "traitName": "of",
                                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                        }
                                      },
                                      {
                                        "traitName": "explains.application",
                                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                        "verb": {
                                          "traitName": "qualifiedBy",
                                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                        }
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person"
                                    }
                                  ]
                                }
                              ]
                            },
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "options.anyOf",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "person.initials",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.firstName",
                                    "explanation": "A person's given or first name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.middleName",
                                    "explanation": "A person's middle name",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.prefix",
                                    "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastNamePrefix",
                                    "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastName",
                                    "explanation": "A person's surname, family name or last name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.suffix",
                                    "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            "traitName": "person.title",
                            "explanation": "A personal or professional title",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.age",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.birthDate",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.ethnicity",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "businessProcess",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "businessProcess",
        "references": {
          "traitName": "businessProcess",
          "verb": {
            "traitName": "means",
            "references": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "entityType",
        "references": {
          "traitName": "entityType",
          "explanation": "the concept of a CDM entity. Used to classify other traits that describe concepts commonly represented by entities. the trait for 'customer' would be classified as an 'entityType'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"gendercode":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "person.genderKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.gender",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "constrainedList.kindOfMapping",
        "explanation": "The values of an attribute can be mapped (using the values in this table) into a standard set of 'kindOf' trait references",
        "verb": {
          "traitName": "has",
          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
        },
        "argumentValues": {
          "defaultList": {
            "entityReference": {
              "explanation": "The constantValues below correspond to the attributes of the 'listLookupKindOfMapping' entityShape which are: {attributeValue, traitPath}",
              "entityShape": "listLookupKindOfMapping",
              "constantValues": [
                [
                  "2",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.female"
                ],
                [
                  "1",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.male"
                ],
                [
                  "0",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.unknown"
                ],
                [
                  "",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.unknown"
                ]
              ]
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"familystatuscode":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "person.maritalStatusKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.maritalStatus",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"contactid":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      },
      {
        "traitName": "is.dataFormat.guid",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "means",
          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.guid",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.identity.entityId",
    "explanation": "redefined older name convention of same concept (see the extended trait)",
    "IS_A": {
      "traitName": "identity.entityId",
      "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
      "IS_A": {
        "traitName": "identity.global",
        "explanation": "a number, uuid or string used to identify something globally",
        "IS_A": {
          "traitName": "means.identity",
          "explanation": "some form of identifying information"
        },
        "metaTraits": [
          {
            "traitName": "identity.identityKind",
            "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "means.identity",
                  "explanation": "some form of identifying information",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  }
                },
                {
                  "traitName": "explains.application",
                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "entityRecord",
                "explanation": "the concept of an individual record of data that is an instance of an entityType",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.guid",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"msfsi_joindate":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "qualification.effective",
        "explanation": "active, in-place or established such as effective date or effective agreement",
        "verb": {
          "traitName": "means",
          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
        }
      },
      {
        "traitName": "commerce.customer",
        "explanation": "a party in the role of customer who purchase or uses products",
        "IS_A": {
          "traitName": "commerce.party",
          "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
          "references": {
            "traitName": "commerce.party",
            "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
            "metaTraits": [
              {
                "traitName": "options.oneOf",
                "verb": {
                  "traitName": "contains",
                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                },
                "metaTraits": [
                  {
                    "traitName": "commerce.individual",
                    "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                    "IS_A": {
                      "traitName": "person",
                      "references": {
                        "traitName": "person",
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "metaTraits": [
                          {
                            "traitName": "options.anyOf",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "person.fullName",
                                "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                "IS_A": {
                                  "traitName": "identity.completeName",
                                  "IS_A": {
                                    "traitName": "identity.name",
                                    "explanation": "the words by which something is known or called",
                                    "IS_A": {
                                      "traitName": "means.identity",
                                      "explanation": "some form of identifying information"
                                    }
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "identity.identityKind",
                                      "IS_A": {
                                        "traitName": "kindOf",
                                        "IS_A": {
                                          "traitName": "means",
                                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information",
                                            "verb": {
                                              "traitName": "of",
                                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                            }
                                          },
                                          {
                                            "traitName": "explains.application",
                                            "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                            "verb": {
                                              "traitName": "qualifiedBy",
                                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                            }
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "options.anyOf",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person.initials",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.firstName",
                                        "explanation": "A person's given or first name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.middleName",
                                        "explanation": "A person's middle name",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.prefix",
                                        "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastNamePrefix",
                                        "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastName",
                                        "explanation": "A person's surname, family name or last name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.suffix",
                                        "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "traitName": "person.title",
                                "explanation": "A personal or professional title",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.age",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.birthDate",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.ethnicity",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              }
                            ]
                          }
                        ]
                      },
                      "metaTraits": [
                        {
                          "traitName": "businessProcess",
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    }
                  },
                  {
                    "traitName": "organization.entity",
                    "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    }
                  }
                ]
              }
            ]
          },
          "metaTraits": [
            {
              "traitName": "action.purchase",
              "explanation": "the act of purchasing",
              "verb": {
                "traitName": "does",
                "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
              },
              "metaTraits": [
                {
                  "traitName": "commerce.product",
                  "explanation": "an item and/or service (IS A oneOf[item, service])",
                  "verb": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "options.oneOf",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "commerce.item",
                          "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        },
                        {
                          "traitName": "commerce.service",
                          "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        "verb": {
          "traitName": "of",
          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"fullname":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "person.fullName",
    "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
    "IS_A": {
      "traitName": "identity.completeName",
      "explanation": "the complete name of something",
      "IS_A": {
        "traitName": "identity.name",
        "explanation": "the words by which something is known or called",
        "IS_A": {
          "traitName": "means.identity",
          "explanation": "some form of identifying information"
        }
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "contains",
            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
          },
          "metaTraits": [
            {
              "traitName": "person",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "options.anyOf",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "person.fullName"
                    },
                    {
                      "traitName": "person.title",
                      "explanation": "A personal or professional title",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "person.age",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "person.birthDate",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "person.ethnicity",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "options.anyOf",
        "verb": {
          "traitName": "contains",
          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
        },
        "metaTraits": [
          {
            "traitName": "person.initials",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.firstName",
            "explanation": "A person's given or first name.",
            "IS_A": {
              "traitName": "identity.name",
              "IS_A": {
                "traitName": "means.identity",
                "explanation": "some form of identifying information"
              },
              "metaTraits": [
                {
                  "traitName": "identity.identityKind",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "means.identity",
                        "explanation": "some form of identifying information",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.application",
                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName"
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.middleName",
            "explanation": "A person's middle name",
            "IS_A": {
              "traitName": "identity.name",
              "IS_A": {
                "traitName": "means.identity",
                "explanation": "some form of identifying information"
              },
              "metaTraits": [
                {
                  "traitName": "identity.identityKind",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "means.identity",
                        "explanation": "some form of identifying information",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.application",
                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName"
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.prefix",
            "explanation": "A salutation such as a rank or honorific to place before a person's name",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.lastNamePrefix",
            "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.lastName",
            "explanation": "A person's surname, family name or last name.",
            "IS_A": {
              "traitName": "identity.name",
              "IS_A": {
                "traitName": "means.identity",
                "explanation": "some form of identifying information"
              },
              "metaTraits": [
                {
                  "traitName": "identity.identityKind",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "means.identity",
                        "explanation": "some form of identifying information",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.application",
                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName"
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.suffix",
            "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"Customer":{"entityProfile":[
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "Customer/(resolvedAttributes)/CustomerId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "commerce.customer",
    "explanation": "a party in the role of customer who purchase or uses products",
    "IS_A": {
      "traitName": "commerce.party",
      "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
      "references": {
        "traitName": "commerce.party",
        "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
        "metaTraits": [
          {
            "traitName": "options.oneOf",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            },
            "metaTraits": [
              {
                "traitName": "commerce.individual",
                "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                "IS_A": {
                  "traitName": "person",
                  "references": {
                    "traitName": "person",
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "options.anyOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "person.fullName",
                            "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                            "IS_A": {
                              "traitName": "identity.completeName",
                              "IS_A": {
                                "traitName": "identity.name",
                                "explanation": "the words by which something is known or called",
                                "IS_A": {
                                  "traitName": "means.identity",
                                  "explanation": "some form of identifying information"
                                }
                              },
                              "metaTraits": [
                                {
                                  "traitName": "identity.identityKind",
                                  "IS_A": {
                                    "traitName": "kindOf",
                                    "IS_A": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information",
                                        "verb": {
                                          "traitName": "of",
                                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                        }
                                      },
                                      {
                                        "traitName": "explains.application",
                                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                        "verb": {
                                          "traitName": "qualifiedBy",
                                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                        }
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person"
                                    }
                                  ]
                                }
                              ]
                            },
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "options.anyOf",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "person.initials",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.firstName",
                                    "explanation": "A person's given or first name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.middleName",
                                    "explanation": "A person's middle name",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.prefix",
                                    "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastNamePrefix",
                                    "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastName",
                                    "explanation": "A person's surname, family name or last name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.suffix",
                                    "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            "traitName": "person.title",
                            "explanation": "A personal or professional title",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.age",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.birthDate",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.ethnicity",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "businessProcess",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "contains",
                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                }
              },
              {
                "traitName": "organization.entity",
                "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                "verb": {
                  "traitName": "contains",
                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                }
              }
            ]
          }
        ]
      },
      "metaTraits": [
        {
          "traitName": "action.purchase",
          "explanation": "the act of purchasing",
          "verb": {
            "traitName": "does",
            "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "commerce.product",
              "explanation": "an item and/or service (IS A oneOf[item, service])",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "options.oneOf",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "commerce.item",
                      "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "commerce.service",
                      "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "businessProcess",
        "references": {
          "traitName": "businessProcess",
          "verb": {
            "traitName": "means",
            "references": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "entityType",
        "references": {
          "traitName": "entityType",
          "explanation": "the concept of a CDM entity. Used to classify other traits that describe concepts commonly represented by entities. the trait for 'customer' would be classified as an 'entityType'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "A customer is an individual or legal entity that has or has purchased a product or service.\n\nA potential customer is an individual or legal entity that has the desire to acquire a product or service, the financial ability to pay for that product or service and is located in a location in which the product or service can be delivered to them.\n\nThe definition of 'customer' is of critical importance for every organization.    \n\nIt is the customer that is the focus of product planning, marketing, sales, service, reporting and analytics.    Without 'customer' there would be no need for the organization to exist since its purpose is to serve the customer and profit from that interaction.\n\nThe definition of 'customer' must be consistent with how customers exist and interact with the organization in the real world.  An artificial or conceptual definition of 'customer' that is not consistent with these two objectives is doomed to fail because the data will not be consistent with the definition and employees will not accept concepts or terms that are not consistent with what they see, know and how they interact with customers on a working basis.\n\nMicrosoft defines 'customer' to meet these objectives.    When we look out into the real world we see two dominant types of customers:  human beings and legal entities.     \n\nHuman beings are obviously male and female individuals of various ages, sex, demographics and a variety of similar dimensions that describe and define them who purchase products, good and services.    \n\nLegal entities are those legally-defined entities such as corporations, partnerships, non-profit organizations, government organizations etc. that purchase products, goods and services.\n\nThis view of 'customer' is consistent with the real world and consistent with how employees view and interact with customers.\n\nOf course, that is just the start of identifying, defining and understanding each type of 'customer'.     There is a great deal of detail, complexity and related data that can be used to define each type of customer to various levels of detail and different dimensions of information.\n\nMicrosoft implements these detailed concepts and related data via two distinct business area models that expand the coverage and complexity of each type of customer:\n\n-  INDIVIDUAL CUSTOMER Business Area Model\n-  LEGAL ENTITY CUSTOMER Business Area Model\n\nNote:\nEach of the Microsoft models - enterprise, business area or data warehouse - have a representative level of detail for the appropriate type of customer, which is a 'subset' of the total data available in the associated INDIVIDUAL CUSTOMER or LEGAL ENTITY CUSTOMER business area models..   Reference either of those models to expand the coverage or level of detail in each respective data model.\n\nThe actual customer implemented in each model depends upon the dominant use of customer for that industry.     \n\nFor example, in the pharmaceutical industry the customer is a legal entity, which represents another corporation, company, government organization etc. that purchases the pharmaceutical product and then distributes that product to the end-customer, which is an individual in a retail environment or a government-distribution scheme.    \n\nFor this example, the pharmaceutical models will have the legal entity customer represented but not the individual 'end customer' since that is represented in the appropriate retail industry models, which are a different offering.     \n\nOf course, the entire set of data available for a legal entity customer is contained in the associated LEGAL ENTITY CUSTOMER Business Area Model.   Reference the LEGAL ENTITY CUSTOMER Business Area Model to incorporate additional data that may be of relevance.\n\nIn many industries both types of customers are represented since a legal entity or individual can purchase products, goods or services and enter into contracts.    For these industries, both types of customers are represented by some of the more significant or relevant data derived from the associated LEGAL ENTITY or INDIVIDUAL CUSTOMER business area models.   These models can be used to expand the scope or level of detail in any of the enterprise, business area or data warehouse models."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"CustomerId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          },
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "Customer/(resolvedAttributes)/CustomerId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "means.identity.entityId",
    "explanation": "redefined older name convention of same concept (see the extended trait)",
    "IS_A": {
      "traitName": "identity.entityId",
      "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
      "IS_A": {
        "traitName": "identity.global",
        "explanation": "a number, uuid or string used to identify something globally",
        "IS_A": {
          "traitName": "means.identity",
          "explanation": "some form of identifying information"
        },
        "metaTraits": [
          {
            "traitName": "identity.identityKind",
            "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "means.identity",
                  "explanation": "some form of identifying information",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  }
                },
                {
                  "traitName": "explains.application",
                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "entityRecord",
                "explanation": "the concept of an individual record of data that is an instance of an entityType",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Customer."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"CustomerEstablishedDate":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "qualification.effective",
        "explanation": "active, in-place or established such as effective date or effective agreement",
        "verb": {
          "traitName": "means",
          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The date that the Customer relationship was established."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer Established Date"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"PartyId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          },
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Party."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Party ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.linkedEntity.identifier",
    "explanation": "Marks the attribute(s) that hold foreign key references to a linked (used as an attribute) entity. This attribute is added to the resolved entity to enumerate the referenced entities.",
    "IS_A": {
      "traitName": "is.linkedEntity",
      "explanation": "base for traits that are used to decorate the attributes and artifacts created by the traits on the hasFlexibleRelationshipWithEntity relationship."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "entityReferences": {
        "entityReference": {
          "entityShape": "entityGroupSet",
          "constantValues": [
            [
              "miniContact.cdm.json/Party",
              "PartyId"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"CustomerGender":{"entityProfile":[
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "CustomerGender/(resolvedAttributes)/PeriodStartDate"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "commerce.individualCustomer",
    "explanation": "a party in the role of customer who purchase or uses products",
    "IS_A": {
      "traitName": "commerce.customer",
      "explanation": "a party in the role of customer who purchase or uses products",
      "IS_A": {
        "traitName": "commerce.party",
        "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
        "references": {
          "traitName": "commerce.party",
          "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
          "metaTraits": [
            {
              "traitName": "options.oneOf",
              "verb": {
                "traitName": "contains",
                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
              },
              "metaTraits": [
                {
                  "traitName": "commerce.individual",
                  "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                  "IS_A": {
                    "traitName": "person",
                    "references": {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName",
                              "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                              "IS_A": {
                                "traitName": "identity.completeName",
                                "IS_A": {
                                  "traitName": "identity.name",
                                  "explanation": "the words by which something is known or called",
                                  "IS_A": {
                                    "traitName": "means.identity",
                                    "explanation": "some form of identifying information"
                                  }
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "identity.identityKind",
                                    "IS_A": {
                                      "traitName": "kindOf",
                                      "IS_A": {
                                        "traitName": "means",
                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information",
                                          "verb": {
                                            "traitName": "of",
                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                          }
                                        },
                                        {
                                          "traitName": "explains.application",
                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                          "verb": {
                                            "traitName": "qualifiedBy",
                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                          }
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person"
                                      }
                                    ]
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.initials",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.firstName",
                                      "explanation": "A person's given or first name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.middleName",
                                      "explanation": "A person's middle name",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.prefix",
                                      "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastNamePrefix",
                                      "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastName",
                                      "explanation": "A person's surname, family name or last name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.suffix",
                                      "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    "metaTraits": [
                      {
                        "traitName": "businessProcess",
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                },
                {
                  "traitName": "organization.entity",
                  "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                }
              ]
            }
          ]
        },
        "metaTraits": [
          {
            "traitName": "action.purchase",
            "explanation": "the act of purchasing",
            "verb": {
              "traitName": "does",
              "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "commerce.product",
                "explanation": "an item and/or service (IS A oneOf[item, service])",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                },
                "metaTraits": [
                  {
                    "traitName": "options.oneOf",
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    },
                    "metaTraits": [
                      {
                        "traitName": "commerce.item",
                        "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      },
                      {
                        "traitName": "commerce.service",
                        "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      "metaTraits": [
        {
          "traitName": "commerce.partyKind.individual",
          "explanation": "indicates a individual party",
          "IS_A": {
            "traitName": "commerce.partyKind",
            "explanation": "a type indicator for kinds of parties",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "commerce.party",
                  "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "options.oneOf",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "commerce.individual",
                          "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                          "IS_A": {
                            "traitName": "person",
                            "references": {
                              "traitName": "person",
                              "verb": {
                                "traitName": "means",
                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.fullName",
                                      "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                      "IS_A": {
                                        "traitName": "identity.completeName",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "explanation": "the words by which something is known or called",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          }
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "contains",
                                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "options.anyOf",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person.initials",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.firstName",
                                              "explanation": "A person's given or first name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.middleName",
                                              "explanation": "A person's middle name",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.prefix",
                                              "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastNamePrefix",
                                              "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastName",
                                              "explanation": "A person's surname, family name or last name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.suffix",
                                              "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "traitName": "person.title",
                                      "explanation": "A personal or professional title",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.age",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.birthDate",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.ethnicity",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            "metaTraits": [
                              {
                                "traitName": "businessProcess",
                                "verb": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                }
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        },
                        {
                          "traitName": "organization.entity",
                          "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        }
                      ]
                    }
                  ]
                },
                {
                  "traitName": "explains.entity",
                  "explanation": "explaining that one concept or type indicator gives the 'type of thing' for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "metaTraits": [
              {
                "traitName": "commerce.individual",
                "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                "IS_A": {
                  "traitName": "person",
                  "references": {
                    "traitName": "person",
                    "metaTraits": [
                      {
                        "traitName": "options.anyOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "person.fullName",
                            "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                            "IS_A": {
                              "traitName": "identity.completeName",
                              "IS_A": {
                                "traitName": "identity.name",
                                "explanation": "the words by which something is known or called",
                                "IS_A": {
                                  "traitName": "means.identity",
                                  "explanation": "some form of identifying information"
                                }
                              },
                              "metaTraits": [
                                {
                                  "traitName": "identity.identityKind",
                                  "IS_A": {
                                    "traitName": "kindOf",
                                    "IS_A": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information",
                                        "verb": {
                                          "traitName": "of",
                                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                        }
                                      },
                                      {
                                        "traitName": "explains.application",
                                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                        "verb": {
                                          "traitName": "qualifiedBy",
                                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                        }
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person"
                                    }
                                  ]
                                }
                              ]
                            },
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "options.anyOf",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "person.initials",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.firstName",
                                    "explanation": "A person's given or first name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.middleName",
                                    "explanation": "A person's middle name",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.prefix",
                                    "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastNamePrefix",
                                    "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastName",
                                    "explanation": "A person's surname, family name or last name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.suffix",
                                    "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            "traitName": "person.title",
                            "explanation": "A personal or professional title",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.age",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.birthDate",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.ethnicity",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "businessProcess",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "businessProcess",
        "references": {
          "traitName": "businessProcess",
          "verb": {
            "traitName": "means",
            "references": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "entityType",
        "references": {
          "traitName": "entityType",
          "explanation": "the concept of a CDM entity. Used to classify other traits that describe concepts commonly represented by entities. the trait for 'customer' would be classified as an 'entityType'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "person.genderKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.gender",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer Gender"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The gender associated with the Customer.\nThe gender that an individual associates with can change over a period of time and is represented with 'period start date/period end date' qualifications, which represented the best case for knowing this information."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"CustomerId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          },
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "identity.entityId",
    "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
    "IS_A": {
      "traitName": "identity.global",
      "explanation": "a number, uuid or string used to identify something globally",
      "IS_A": {
        "traitName": "means.identity",
        "explanation": "some form of identifying information"
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "entityRecord",
              "explanation": "the concept of an individual record of data that is an instance of an entityType",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              }
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "commerce.individualCustomer",
        "explanation": "a party in the role of customer who purchase or uses products",
        "IS_A": {
          "traitName": "commerce.customer",
          "explanation": "a party in the role of customer who purchase or uses products",
          "IS_A": {
            "traitName": "commerce.party",
            "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
            "references": {
              "traitName": "commerce.party",
              "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
              "metaTraits": [
                {
                  "traitName": "options.oneOf",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "commerce.individual",
                      "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                      "IS_A": {
                        "traitName": "person",
                        "references": {
                          "traitName": "person",
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          },
                          "metaTraits": [
                            {
                              "traitName": "options.anyOf",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              },
                              "metaTraits": [
                                {
                                  "traitName": "person.fullName",
                                  "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                  "IS_A": {
                                    "traitName": "identity.completeName",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "explanation": "the words by which something is known or called",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      }
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "identity.identityKind",
                                        "IS_A": {
                                          "traitName": "kindOf",
                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                          "IS_A": {
                                            "traitName": "means",
                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information",
                                              "verb": {
                                                "traitName": "of",
                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                              }
                                            },
                                            {
                                              "traitName": "explains.application",
                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                              "verb": {
                                                "traitName": "qualifiedBy",
                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                              }
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "person"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "options.anyOf",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person.initials",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.firstName",
                                          "explanation": "A person's given or first name.",
                                          "IS_A": {
                                            "traitName": "identity.name",
                                            "IS_A": {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "has",
                                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.middleName",
                                          "explanation": "A person's middle name",
                                          "IS_A": {
                                            "traitName": "identity.name",
                                            "IS_A": {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "has",
                                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.prefix",
                                          "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.lastNamePrefix",
                                          "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.lastName",
                                          "explanation": "A person's surname, family name or last name.",
                                          "IS_A": {
                                            "traitName": "identity.name",
                                            "IS_A": {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "has",
                                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.suffix",
                                          "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "traitName": "person.title",
                                  "explanation": "A personal or professional title",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                },
                                {
                                  "traitName": "person.age",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                },
                                {
                                  "traitName": "person.birthDate",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                },
                                {
                                  "traitName": "person.ethnicity",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "metaTraits": [
                          {
                            "traitName": "businessProcess",
                            "verb": {
                              "traitName": "means",
                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                            }
                          }
                        ]
                      },
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "organization.entity",
                      "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    }
                  ]
                }
              ]
            },
            "metaTraits": [
              {
                "traitName": "action.purchase",
                "explanation": "the act of purchasing",
                "verb": {
                  "traitName": "does",
                  "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "commerce.product",
                    "explanation": "an item and/or service (IS A oneOf[item, service])",
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "options.oneOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "commerce.item",
                            "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "commerce.service",
                            "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "metaTraits": [
            {
              "traitName": "commerce.partyKind.individual",
              "explanation": "indicates a individual party",
              "IS_A": {
                "traitName": "commerce.partyKind",
                "explanation": "a type indicator for kinds of parties",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "commerce.party",
                      "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.oneOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "commerce.individual",
                              "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                              "IS_A": {
                                "traitName": "person",
                                "references": {
                                  "traitName": "person",
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "options.anyOf",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person.fullName",
                                          "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                          "IS_A": {
                                            "traitName": "identity.completeName",
                                            "IS_A": {
                                              "traitName": "identity.name",
                                              "explanation": "the words by which something is known or called",
                                              "IS_A": {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information"
                                              }
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "contains",
                                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "options.anyOf",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person.initials",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.firstName",
                                                  "explanation": "A person's given or first name.",
                                                  "IS_A": {
                                                    "traitName": "identity.name",
                                                    "IS_A": {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information"
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "identity.identityKind",
                                                        "IS_A": {
                                                          "traitName": "kindOf",
                                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                          "IS_A": {
                                                            "traitName": "means",
                                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                          },
                                                          "metaTraits": [
                                                            {
                                                              "traitName": "means.identity",
                                                              "explanation": "some form of identifying information",
                                                              "verb": {
                                                                "traitName": "of",
                                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                              }
                                                            },
                                                            {
                                                              "traitName": "explains.application",
                                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                              "verb": {
                                                                "traitName": "qualifiedBy",
                                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                              }
                                                            }
                                                          ]
                                                        },
                                                        "verb": {
                                                          "traitName": "has",
                                                          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                        },
                                                        "metaTraits": [
                                                          {
                                                            "traitName": "person"
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  },
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.middleName",
                                                  "explanation": "A person's middle name",
                                                  "IS_A": {
                                                    "traitName": "identity.name",
                                                    "IS_A": {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information"
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "identity.identityKind",
                                                        "IS_A": {
                                                          "traitName": "kindOf",
                                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                          "IS_A": {
                                                            "traitName": "means",
                                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                          },
                                                          "metaTraits": [
                                                            {
                                                              "traitName": "means.identity",
                                                              "explanation": "some form of identifying information",
                                                              "verb": {
                                                                "traitName": "of",
                                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                              }
                                                            },
                                                            {
                                                              "traitName": "explains.application",
                                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                              "verb": {
                                                                "traitName": "qualifiedBy",
                                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                              }
                                                            }
                                                          ]
                                                        },
                                                        "verb": {
                                                          "traitName": "has",
                                                          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                        },
                                                        "metaTraits": [
                                                          {
                                                            "traitName": "person"
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  },
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.prefix",
                                                  "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.lastNamePrefix",
                                                  "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.lastName",
                                                  "explanation": "A person's surname, family name or last name.",
                                                  "IS_A": {
                                                    "traitName": "identity.name",
                                                    "IS_A": {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information"
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "identity.identityKind",
                                                        "IS_A": {
                                                          "traitName": "kindOf",
                                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                          "IS_A": {
                                                            "traitName": "means",
                                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                          },
                                                          "metaTraits": [
                                                            {
                                                              "traitName": "means.identity",
                                                              "explanation": "some form of identifying information",
                                                              "verb": {
                                                                "traitName": "of",
                                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                              }
                                                            },
                                                            {
                                                              "traitName": "explains.application",
                                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                              "verb": {
                                                                "traitName": "qualifiedBy",
                                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                              }
                                                            }
                                                          ]
                                                        },
                                                        "verb": {
                                                          "traitName": "has",
                                                          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                        },
                                                        "metaTraits": [
                                                          {
                                                            "traitName": "person"
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  },
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.suffix",
                                                  "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "traitName": "person.title",
                                          "explanation": "A personal or professional title",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.age",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.birthDate",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.ethnicity",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "businessProcess",
                                    "verb": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "organization.entity",
                              "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "traitName": "explains.entity",
                      "explanation": "explaining that one concept or type indicator gives the 'type of thing' for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "commerce.individual",
                    "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                    "IS_A": {
                      "traitName": "person",
                      "references": {
                        "traitName": "person",
                        "metaTraits": [
                          {
                            "traitName": "options.anyOf",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "person.fullName",
                                "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                "IS_A": {
                                  "traitName": "identity.completeName",
                                  "IS_A": {
                                    "traitName": "identity.name",
                                    "explanation": "the words by which something is known or called",
                                    "IS_A": {
                                      "traitName": "means.identity",
                                      "explanation": "some form of identifying information"
                                    }
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "identity.identityKind",
                                      "IS_A": {
                                        "traitName": "kindOf",
                                        "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                        "IS_A": {
                                          "traitName": "means",
                                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information",
                                            "verb": {
                                              "traitName": "of",
                                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                            }
                                          },
                                          {
                                            "traitName": "explains.application",
                                            "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                            "verb": {
                                              "traitName": "qualifiedBy",
                                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                            }
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "options.anyOf",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person.initials",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.firstName",
                                        "explanation": "A person's given or first name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.middleName",
                                        "explanation": "A person's middle name",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.prefix",
                                        "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastNamePrefix",
                                        "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastName",
                                        "explanation": "A person's surname, family name or last name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.suffix",
                                        "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "traitName": "person.title",
                                "explanation": "A personal or professional title",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.age",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.birthDate",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.ethnicity",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              }
                            ]
                          }
                        ]
                      },
                      "metaTraits": [
                        {
                          "traitName": "businessProcess",
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              }
            }
          ]
        },
        "verb": {
          "traitName": "of",
          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
        }
      }
    ]
  },
  {
    "traitName": "has.schemaObjectIdentifier",
    "explanation": "The schema object has an identifier, which is a string, specified as the parameter of the trait. This allows writers to define additional identification values.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "identifier": "{02C45237-A643-4782-9702-FD03D8D95518}"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Customer."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.linkedEntity.identifier",
    "explanation": "Marks the attribute(s) that hold foreign key references to a linked (used as an attribute) entity. This attribute is added to the resolved entity to enumerate the referenced entities.",
    "IS_A": {
      "traitName": "is.linkedEntity",
      "explanation": "base for traits that are used to decorate the attributes and artifacts created by the traits on the hasFlexibleRelationshipWithEntity relationship."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "entityReferences": {
        "entityReference": {
          "entityShape": "entitySet",
          "constantValues": [
            [
              "miniContact.cdm.json/IndividualCustomer",
              "CustomerId",
              "customer_IndividualCustomer"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"PeriodStartDate":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "CustomerGender/(resolvedAttributes)/PeriodStartDate"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date.start.scd",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "means.measurement.date",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dayOfEra",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time.day",
          "explanation": "a measurement for duration of time in units of days",
          "IS_A": {
            "traitName": "measurement.dimension.time",
            "explanation": "measurement of time",
            "IS_A": {
              "traitName": "measurement.dimension",
              "explanation": "measurement of some physical dimension",
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            }
          },
          "metaTraits": [
            {
              "traitName": "measurement.unit.time.day",
              "explanation": "A solar day, here on earth as a measurement unit for duration of time",
              "IS_A": {
                "traitName": "measurement.unit.time",
                "explanation": "a unit of measurement for the time dimension",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "references": {
                    "traitName": "measurement.unit",
                    "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "classifications": [
                      {
                        "traitName": "measurement",
                        "references": {
                          "traitName": "measurement",
                          "explanation": "use to classify objects or other traits",
                          "verb": {
                            "traitName": "classifiedAs",
                            "references": {
                              "traitName": "classifiedAs",
                              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                            }
                          }
                        },
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      }
                    ],
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension",
                        "explanation": "measurement of some physical dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "measurement.unitKind",
                      "IS_A": {
                        "traitName": "kindOf",
                        "IS_A": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "metaTraits": [
                          {
                            "traitName": "measurement.unit",
                            "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                            "verb": {
                              "traitName": "of",
                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimension",
                                "explanation": "measurement of some physical dimension",
                                "verb": {
                                  "traitName": "of",
                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                }
                              }
                            ]
                          },
                          {
                            "traitName": "explains.subType",
                            "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                            "verb": {
                              "traitName": "qualifiedBy",
                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                            }
                          }
                        ]
                      },
                      "verb": {
                        "traitName": "has",
                        "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.dimension.time",
                          "explanation": "measurement of time",
                          "IS_A": {
                            "traitName": "measurement.dimension",
                            "explanation": "measurement of some physical dimension",
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimensionKind",
                                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                                "IS_A": {
                                  "traitName": "kindOf",
                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                  "IS_A": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension",
                                      "verb": {
                                        "traitName": "of",
                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                      }
                                    },
                                    {
                                      "traitName": "explains.subType",
                                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                      "verb": {
                                        "traitName": "qualifiedBy",
                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                      }
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "has",
                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension.time",
                                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                    "IS_A": {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension"
                                    },
                                    "verb": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          },
                          "argumentValues": {
                            "dimension": "time"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "day",
                "symbol": "D",
                "dimension": "time"
              }
            },
            {
              "traitName": "has.measurement.fundamentalComponent.second",
              "explanation": "the fundamental component of time in seconds",
              "IS_A": {
                "traitName": "has.measurement.fundamentalComponent",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.dimensionKind",
                    "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                    "IS_A": {
                      "traitName": "kindOf",
                      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          }
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension.time",
                        "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                        "IS_A": {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension"
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  }
                ]
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "second",
                "symbol": "s",
                "dimension": "time",
                "fundamentalExponent": "1",
                "fundamentalScale": "86400",
                "fundamentalOffset": "0"
              }
            }
          ]
        }
      },
      "metaTraits": [
        {
          "traitName": "action.start",
          "explanation": "initiate the state or indicate the moment of being started or begun (started / completed)",
          "verb": {
            "traitName": "means",
            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
          }
        },
        {
          "traitName": "qualification.effective",
          "explanation": "active, in-place or established such as effective date or effective agreement",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The period start date for which the associated data is effective or 'as-of'."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Period Start Date"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"PeriodEndDate":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date.end.scd",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "means.measurement.date",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dayOfEra",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time.day",
          "explanation": "a measurement for duration of time in units of days",
          "IS_A": {
            "traitName": "measurement.dimension.time",
            "explanation": "measurement of time",
            "IS_A": {
              "traitName": "measurement.dimension",
              "explanation": "measurement of some physical dimension",
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            }
          },
          "metaTraits": [
            {
              "traitName": "measurement.unit.time.day",
              "explanation": "A solar day, here on earth as a measurement unit for duration of time",
              "IS_A": {
                "traitName": "measurement.unit.time",
                "explanation": "a unit of measurement for the time dimension",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "references": {
                    "traitName": "measurement.unit",
                    "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "classifications": [
                      {
                        "traitName": "measurement",
                        "references": {
                          "traitName": "measurement",
                          "explanation": "use to classify objects or other traits",
                          "verb": {
                            "traitName": "classifiedAs",
                            "references": {
                              "traitName": "classifiedAs",
                              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                            }
                          }
                        },
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      }
                    ],
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension",
                        "explanation": "measurement of some physical dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "measurement.unitKind",
                      "IS_A": {
                        "traitName": "kindOf",
                        "IS_A": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "metaTraits": [
                          {
                            "traitName": "measurement.unit",
                            "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                            "verb": {
                              "traitName": "of",
                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimension",
                                "explanation": "measurement of some physical dimension",
                                "verb": {
                                  "traitName": "of",
                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                }
                              }
                            ]
                          },
                          {
                            "traitName": "explains.subType",
                            "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                            "verb": {
                              "traitName": "qualifiedBy",
                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                            }
                          }
                        ]
                      },
                      "verb": {
                        "traitName": "has",
                        "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.dimension.time",
                          "explanation": "measurement of time",
                          "IS_A": {
                            "traitName": "measurement.dimension",
                            "explanation": "measurement of some physical dimension",
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimensionKind",
                                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                                "IS_A": {
                                  "traitName": "kindOf",
                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                  "IS_A": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension",
                                      "verb": {
                                        "traitName": "of",
                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                      }
                                    },
                                    {
                                      "traitName": "explains.subType",
                                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                      "verb": {
                                        "traitName": "qualifiedBy",
                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                      }
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "has",
                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension.time",
                                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                    "IS_A": {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension"
                                    },
                                    "verb": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          },
                          "argumentValues": {
                            "dimension": "time"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "day",
                "symbol": "D",
                "dimension": "time"
              }
            },
            {
              "traitName": "has.measurement.fundamentalComponent.second",
              "explanation": "the fundamental component of time in seconds",
              "IS_A": {
                "traitName": "has.measurement.fundamentalComponent",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.dimensionKind",
                    "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                    "IS_A": {
                      "traitName": "kindOf",
                      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          }
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension.time",
                        "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                        "IS_A": {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension"
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  }
                ]
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "second",
                "symbol": "s",
                "dimension": "time",
                "fundamentalExponent": "1",
                "fundamentalScale": "86400",
                "fundamentalOffset": "0"
              }
            }
          ]
        }
      },
      "metaTraits": [
        {
          "traitName": "action.complete",
          "explanation": "initiate the state or indicate the moment of being completed or finished or ending (started / completed)",
          "verb": {
            "traitName": "means",
            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
          }
        },
        {
          "traitName": "qualification.effective",
          "explanation": "active, in-place or established such as effective date or effective agreement",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "rowSelectionCriteria.null",
    "explanation": "(see rowSelectionCriteria) The affected attribute indicates a selected value when the attribute value is null. Example: from a group of possible records, pick the one where 'periodEndDate' is NULL.",
    "IS_A": {
      "traitName": "rowSelectionCriteria",
      "explanation": "Applied to attributes (with a 'means' or 'has' verb) to express that the attribute should be used in some way to select or disambiguate a given record from a set of other records.",
      "metaTraits": [
        {
          "traitName": "qualification.null",
          "explanation": "a value should not exist (null/exists/true/false/minimum/maximum)",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The period end date for which the associated data is effective or 'as-of'."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Period End Date"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"GenderId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "identity.entityId",
    "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
    "IS_A": {
      "traitName": "identity.global",
      "explanation": "a number, uuid or string used to identify something globally",
      "IS_A": {
        "traitName": "means.identity",
        "explanation": "some form of identifying information"
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "entityRecord",
              "explanation": "the concept of an individual record of data that is an instance of an entityType",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              }
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "person.genderKind",
        "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
        "IS_A": {
          "traitName": "kindOf",
          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
          "IS_A": {
            "traitName": "means",
            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
          },
          "metaTraits": [
            {
              "traitName": "person.gender",
              "verb": {
                "traitName": "of",
                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
              }
            },
            {
              "traitName": "explains.subType",
              "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
              "verb": {
                "traitName": "qualifiedBy",
                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
              }
            }
          ]
        },
        "verb": {
          "traitName": "of",
          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Gender."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Gender ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.linkedEntity.identifier",
    "explanation": "Marks the attribute(s) that hold foreign key references to a linked (used as an attribute) entity. This attribute is added to the resolved entity to enumerate the referenced entities.",
    "IS_A": {
      "traitName": "is.linkedEntity",
      "explanation": "base for traits that are used to decorate the attributes and artifacts created by the traits on the hasFlexibleRelationshipWithEntity relationship."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "entityReferences": {
        "entityReference": {
          "entityShape": "entityGroupSet",
          "constantValues": [
            [
              "miniContact.cdm.json/Gender",
              "GenderId"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"CustomerGenderNote":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "A note, comment or additional information regarding the Customer's gender."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer Gender Note"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "2048"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"CustomerMaritalStatus":{"entityProfile":[
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "CustomerMaritalStatus/(resolvedAttributes)/PeriodStartDate"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "commerce.individualCustomer",
    "explanation": "a party in the role of customer who purchase or uses products",
    "IS_A": {
      "traitName": "commerce.customer",
      "explanation": "a party in the role of customer who purchase or uses products",
      "IS_A": {
        "traitName": "commerce.party",
        "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
        "references": {
          "traitName": "commerce.party",
          "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
          "metaTraits": [
            {
              "traitName": "options.oneOf",
              "verb": {
                "traitName": "contains",
                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
              },
              "metaTraits": [
                {
                  "traitName": "commerce.individual",
                  "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                  "IS_A": {
                    "traitName": "person",
                    "references": {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName",
                              "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                              "IS_A": {
                                "traitName": "identity.completeName",
                                "IS_A": {
                                  "traitName": "identity.name",
                                  "explanation": "the words by which something is known or called",
                                  "IS_A": {
                                    "traitName": "means.identity",
                                    "explanation": "some form of identifying information"
                                  }
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "identity.identityKind",
                                    "IS_A": {
                                      "traitName": "kindOf",
                                      "IS_A": {
                                        "traitName": "means",
                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information",
                                          "verb": {
                                            "traitName": "of",
                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                          }
                                        },
                                        {
                                          "traitName": "explains.application",
                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                          "verb": {
                                            "traitName": "qualifiedBy",
                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                          }
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person"
                                      }
                                    ]
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.initials",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.firstName",
                                      "explanation": "A person's given or first name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.middleName",
                                      "explanation": "A person's middle name",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.prefix",
                                      "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastNamePrefix",
                                      "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastName",
                                      "explanation": "A person's surname, family name or last name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.suffix",
                                      "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    "metaTraits": [
                      {
                        "traitName": "businessProcess",
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                },
                {
                  "traitName": "organization.entity",
                  "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                }
              ]
            }
          ]
        },
        "metaTraits": [
          {
            "traitName": "action.purchase",
            "explanation": "the act of purchasing",
            "verb": {
              "traitName": "does",
              "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "commerce.product",
                "explanation": "an item and/or service (IS A oneOf[item, service])",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                },
                "metaTraits": [
                  {
                    "traitName": "options.oneOf",
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    },
                    "metaTraits": [
                      {
                        "traitName": "commerce.item",
                        "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      },
                      {
                        "traitName": "commerce.service",
                        "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      "metaTraits": [
        {
          "traitName": "commerce.partyKind.individual",
          "explanation": "indicates a individual party",
          "IS_A": {
            "traitName": "commerce.partyKind",
            "explanation": "a type indicator for kinds of parties",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "commerce.party",
                  "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "options.oneOf",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "commerce.individual",
                          "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                          "IS_A": {
                            "traitName": "person",
                            "references": {
                              "traitName": "person",
                              "verb": {
                                "traitName": "means",
                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.fullName",
                                      "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                      "IS_A": {
                                        "traitName": "identity.completeName",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "explanation": "the words by which something is known or called",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          }
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "contains",
                                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "options.anyOf",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person.initials",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.firstName",
                                              "explanation": "A person's given or first name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.middleName",
                                              "explanation": "A person's middle name",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.prefix",
                                              "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastNamePrefix",
                                              "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastName",
                                              "explanation": "A person's surname, family name or last name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.suffix",
                                              "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "traitName": "person.title",
                                      "explanation": "A personal or professional title",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.age",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.birthDate",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.ethnicity",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            "metaTraits": [
                              {
                                "traitName": "businessProcess",
                                "verb": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                }
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        },
                        {
                          "traitName": "organization.entity",
                          "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        }
                      ]
                    }
                  ]
                },
                {
                  "traitName": "explains.entity",
                  "explanation": "explaining that one concept or type indicator gives the 'type of thing' for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "metaTraits": [
              {
                "traitName": "commerce.individual",
                "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                "IS_A": {
                  "traitName": "person",
                  "references": {
                    "traitName": "person",
                    "metaTraits": [
                      {
                        "traitName": "options.anyOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "person.fullName",
                            "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                            "IS_A": {
                              "traitName": "identity.completeName",
                              "IS_A": {
                                "traitName": "identity.name",
                                "explanation": "the words by which something is known or called",
                                "IS_A": {
                                  "traitName": "means.identity",
                                  "explanation": "some form of identifying information"
                                }
                              },
                              "metaTraits": [
                                {
                                  "traitName": "identity.identityKind",
                                  "IS_A": {
                                    "traitName": "kindOf",
                                    "IS_A": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information",
                                        "verb": {
                                          "traitName": "of",
                                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                        }
                                      },
                                      {
                                        "traitName": "explains.application",
                                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                        "verb": {
                                          "traitName": "qualifiedBy",
                                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                        }
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person"
                                    }
                                  ]
                                }
                              ]
                            },
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "options.anyOf",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "person.initials",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.firstName",
                                    "explanation": "A person's given or first name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.middleName",
                                    "explanation": "A person's middle name",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.prefix",
                                    "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastNamePrefix",
                                    "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastName",
                                    "explanation": "A person's surname, family name or last name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.suffix",
                                    "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            "traitName": "person.title",
                            "explanation": "A personal or professional title",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.age",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.birthDate",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.ethnicity",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "businessProcess",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "businessProcess",
        "references": {
          "traitName": "businessProcess",
          "verb": {
            "traitName": "means",
            "references": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "entityType",
        "references": {
          "traitName": "entityType",
          "explanation": "the concept of a CDM entity. Used to classify other traits that describe concepts commonly represented by entities. the trait for 'customer' would be classified as an 'entityType'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "person.maritalStatusKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.maritalStatus",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer Marital Status"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The marital status of the Individual Customer.\n\nThese criteria can change over a period of time and are represented with 'period start date/period end date' qualifications, which represented the best case for knowing this information.    If the data is only randomly sampled or recorded then you could use a single 'date' to identify its recording or effective as-of date."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"CustomerId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          },
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "CustomerMaritalStatus/(resolvedAttributes)/CustomerId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.linkedEntity.identifier",
    "explanation": "Marks the attribute(s) that hold foreign key references to a linked (used as an attribute) entity. This attribute is added to the resolved entity to enumerate the referenced entities.",
    "IS_A": {
      "traitName": "is.linkedEntity",
      "explanation": "base for traits that are used to decorate the attributes and artifacts created by the traits on the hasFlexibleRelationshipWithEntity relationship."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "entityReferences": {
        "entityReference": {
          "entityShape": "entityGroupSet",
          "constantValues": [
            [
              "miniContact.cdm.json/IndividualCustomer",
              "CustomerId"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "identity.entityId",
    "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
    "IS_A": {
      "traitName": "identity.global",
      "explanation": "a number, uuid or string used to identify something globally",
      "IS_A": {
        "traitName": "means.identity",
        "explanation": "some form of identifying information"
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "entityRecord",
              "explanation": "the concept of an individual record of data that is an instance of an entityType",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              }
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "commerce.individualCustomer",
        "explanation": "a party in the role of customer who purchase or uses products",
        "IS_A": {
          "traitName": "commerce.customer",
          "explanation": "a party in the role of customer who purchase or uses products",
          "IS_A": {
            "traitName": "commerce.party",
            "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
            "references": {
              "traitName": "commerce.party",
              "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
              "metaTraits": [
                {
                  "traitName": "options.oneOf",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "commerce.individual",
                      "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                      "IS_A": {
                        "traitName": "person",
                        "references": {
                          "traitName": "person",
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          },
                          "metaTraits": [
                            {
                              "traitName": "options.anyOf",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              },
                              "metaTraits": [
                                {
                                  "traitName": "person.fullName",
                                  "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                  "IS_A": {
                                    "traitName": "identity.completeName",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "explanation": "the words by which something is known or called",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      }
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "identity.identityKind",
                                        "IS_A": {
                                          "traitName": "kindOf",
                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                          "IS_A": {
                                            "traitName": "means",
                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information",
                                              "verb": {
                                                "traitName": "of",
                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                              }
                                            },
                                            {
                                              "traitName": "explains.application",
                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                              "verb": {
                                                "traitName": "qualifiedBy",
                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                              }
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "person"
                                          }
                                        ]
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "options.anyOf",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person.initials",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.firstName",
                                          "explanation": "A person's given or first name.",
                                          "IS_A": {
                                            "traitName": "identity.name",
                                            "IS_A": {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "has",
                                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.middleName",
                                          "explanation": "A person's middle name",
                                          "IS_A": {
                                            "traitName": "identity.name",
                                            "IS_A": {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "has",
                                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.prefix",
                                          "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.lastNamePrefix",
                                          "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.lastName",
                                          "explanation": "A person's surname, family name or last name.",
                                          "IS_A": {
                                            "traitName": "identity.name",
                                            "IS_A": {
                                              "traitName": "means.identity",
                                              "explanation": "some form of identifying information"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "has",
                                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.suffix",
                                          "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        }
                                      ]
                                    }
                                  ]
                                },
                                {
                                  "traitName": "person.title",
                                  "explanation": "A personal or professional title",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                },
                                {
                                  "traitName": "person.age",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                },
                                {
                                  "traitName": "person.birthDate",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                },
                                {
                                  "traitName": "person.ethnicity",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "metaTraits": [
                          {
                            "traitName": "businessProcess",
                            "verb": {
                              "traitName": "means",
                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                            }
                          }
                        ]
                      },
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "organization.entity",
                      "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    }
                  ]
                }
              ]
            },
            "metaTraits": [
              {
                "traitName": "action.purchase",
                "explanation": "the act of purchasing",
                "verb": {
                  "traitName": "does",
                  "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "commerce.product",
                    "explanation": "an item and/or service (IS A oneOf[item, service])",
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "options.oneOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "commerce.item",
                            "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "commerce.service",
                            "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "metaTraits": [
            {
              "traitName": "commerce.partyKind.individual",
              "explanation": "indicates a individual party",
              "IS_A": {
                "traitName": "commerce.partyKind",
                "explanation": "a type indicator for kinds of parties",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "commerce.party",
                      "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.oneOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "commerce.individual",
                              "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                              "IS_A": {
                                "traitName": "person",
                                "references": {
                                  "traitName": "person",
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "options.anyOf",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person.fullName",
                                          "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                          "IS_A": {
                                            "traitName": "identity.completeName",
                                            "IS_A": {
                                              "traitName": "identity.name",
                                              "explanation": "the words by which something is known or called",
                                              "IS_A": {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information"
                                              }
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "identity.identityKind",
                                                "IS_A": {
                                                  "traitName": "kindOf",
                                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                  "IS_A": {
                                                    "traitName": "means",
                                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                  },
                                                  "metaTraits": [
                                                    {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information",
                                                      "verb": {
                                                        "traitName": "of",
                                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                      }
                                                    },
                                                    {
                                                      "traitName": "explains.application",
                                                      "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                      "verb": {
                                                        "traitName": "qualifiedBy",
                                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                      }
                                                    }
                                                  ]
                                                },
                                                "verb": {
                                                  "traitName": "contains",
                                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "person"
                                                  }
                                                ]
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "options.anyOf",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person.initials",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.firstName",
                                                  "explanation": "A person's given or first name.",
                                                  "IS_A": {
                                                    "traitName": "identity.name",
                                                    "IS_A": {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information"
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "identity.identityKind",
                                                        "IS_A": {
                                                          "traitName": "kindOf",
                                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                          "IS_A": {
                                                            "traitName": "means",
                                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                          },
                                                          "metaTraits": [
                                                            {
                                                              "traitName": "means.identity",
                                                              "explanation": "some form of identifying information",
                                                              "verb": {
                                                                "traitName": "of",
                                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                              }
                                                            },
                                                            {
                                                              "traitName": "explains.application",
                                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                              "verb": {
                                                                "traitName": "qualifiedBy",
                                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                              }
                                                            }
                                                          ]
                                                        },
                                                        "verb": {
                                                          "traitName": "has",
                                                          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                        },
                                                        "metaTraits": [
                                                          {
                                                            "traitName": "person"
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  },
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.middleName",
                                                  "explanation": "A person's middle name",
                                                  "IS_A": {
                                                    "traitName": "identity.name",
                                                    "IS_A": {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information"
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "identity.identityKind",
                                                        "IS_A": {
                                                          "traitName": "kindOf",
                                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                          "IS_A": {
                                                            "traitName": "means",
                                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                          },
                                                          "metaTraits": [
                                                            {
                                                              "traitName": "means.identity",
                                                              "explanation": "some form of identifying information",
                                                              "verb": {
                                                                "traitName": "of",
                                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                              }
                                                            },
                                                            {
                                                              "traitName": "explains.application",
                                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                              "verb": {
                                                                "traitName": "qualifiedBy",
                                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                              }
                                                            }
                                                          ]
                                                        },
                                                        "verb": {
                                                          "traitName": "has",
                                                          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                        },
                                                        "metaTraits": [
                                                          {
                                                            "traitName": "person"
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  },
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.prefix",
                                                  "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.lastNamePrefix",
                                                  "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.lastName",
                                                  "explanation": "A person's surname, family name or last name.",
                                                  "IS_A": {
                                                    "traitName": "identity.name",
                                                    "IS_A": {
                                                      "traitName": "means.identity",
                                                      "explanation": "some form of identifying information"
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "identity.identityKind",
                                                        "IS_A": {
                                                          "traitName": "kindOf",
                                                          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                          "IS_A": {
                                                            "traitName": "means",
                                                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                          },
                                                          "metaTraits": [
                                                            {
                                                              "traitName": "means.identity",
                                                              "explanation": "some form of identifying information",
                                                              "verb": {
                                                                "traitName": "of",
                                                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                              }
                                                            },
                                                            {
                                                              "traitName": "explains.application",
                                                              "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                              "verb": {
                                                                "traitName": "qualifiedBy",
                                                                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                              }
                                                            }
                                                          ]
                                                        },
                                                        "verb": {
                                                          "traitName": "has",
                                                          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                        },
                                                        "metaTraits": [
                                                          {
                                                            "traitName": "person"
                                                          }
                                                        ]
                                                      }
                                                    ]
                                                  },
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                },
                                                {
                                                  "traitName": "person.suffix",
                                                  "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                                  "verb": {
                                                    "traitName": "contains",
                                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                                  }
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        {
                                          "traitName": "person.title",
                                          "explanation": "A personal or professional title",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.age",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.birthDate",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        },
                                        {
                                          "traitName": "person.ethnicity",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          }
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "businessProcess",
                                    "verb": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "organization.entity",
                              "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "traitName": "explains.entity",
                      "explanation": "explaining that one concept or type indicator gives the 'type of thing' for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "commerce.individual",
                    "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                    "IS_A": {
                      "traitName": "person",
                      "references": {
                        "traitName": "person",
                        "metaTraits": [
                          {
                            "traitName": "options.anyOf",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "person.fullName",
                                "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                "IS_A": {
                                  "traitName": "identity.completeName",
                                  "IS_A": {
                                    "traitName": "identity.name",
                                    "explanation": "the words by which something is known or called",
                                    "IS_A": {
                                      "traitName": "means.identity",
                                      "explanation": "some form of identifying information"
                                    }
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "identity.identityKind",
                                      "IS_A": {
                                        "traitName": "kindOf",
                                        "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                        "IS_A": {
                                          "traitName": "means",
                                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information",
                                            "verb": {
                                              "traitName": "of",
                                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                            }
                                          },
                                          {
                                            "traitName": "explains.application",
                                            "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                            "verb": {
                                              "traitName": "qualifiedBy",
                                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                            }
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "options.anyOf",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person.initials",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.firstName",
                                        "explanation": "A person's given or first name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.middleName",
                                        "explanation": "A person's middle name",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.prefix",
                                        "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastNamePrefix",
                                        "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastName",
                                        "explanation": "A person's surname, family name or last name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.suffix",
                                        "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "traitName": "person.title",
                                "explanation": "A personal or professional title",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.age",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.birthDate",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.ethnicity",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              }
                            ]
                          }
                        ]
                      },
                      "metaTraits": [
                        {
                          "traitName": "businessProcess",
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              }
            }
          ]
        },
        "verb": {
          "traitName": "of",
          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Customer."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"PeriodStartDate":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "CustomerMaritalStatus/(resolvedAttributes)/PeriodStartDate"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date.start.scd",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "means.measurement.date",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dayOfEra",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time.day",
          "explanation": "a measurement for duration of time in units of days",
          "IS_A": {
            "traitName": "measurement.dimension.time",
            "explanation": "measurement of time",
            "IS_A": {
              "traitName": "measurement.dimension",
              "explanation": "measurement of some physical dimension",
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            }
          },
          "metaTraits": [
            {
              "traitName": "measurement.unit.time.day",
              "explanation": "A solar day, here on earth as a measurement unit for duration of time",
              "IS_A": {
                "traitName": "measurement.unit.time",
                "explanation": "a unit of measurement for the time dimension",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "references": {
                    "traitName": "measurement.unit",
                    "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "classifications": [
                      {
                        "traitName": "measurement",
                        "references": {
                          "traitName": "measurement",
                          "explanation": "use to classify objects or other traits",
                          "verb": {
                            "traitName": "classifiedAs",
                            "references": {
                              "traitName": "classifiedAs",
                              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                            }
                          }
                        },
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      }
                    ],
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension",
                        "explanation": "measurement of some physical dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "measurement.unitKind",
                      "IS_A": {
                        "traitName": "kindOf",
                        "IS_A": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "metaTraits": [
                          {
                            "traitName": "measurement.unit",
                            "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                            "verb": {
                              "traitName": "of",
                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimension",
                                "explanation": "measurement of some physical dimension",
                                "verb": {
                                  "traitName": "of",
                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                }
                              }
                            ]
                          },
                          {
                            "traitName": "explains.subType",
                            "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                            "verb": {
                              "traitName": "qualifiedBy",
                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                            }
                          }
                        ]
                      },
                      "verb": {
                        "traitName": "has",
                        "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.dimension.time",
                          "explanation": "measurement of time",
                          "IS_A": {
                            "traitName": "measurement.dimension",
                            "explanation": "measurement of some physical dimension",
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimensionKind",
                                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                                "IS_A": {
                                  "traitName": "kindOf",
                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                  "IS_A": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension",
                                      "verb": {
                                        "traitName": "of",
                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                      }
                                    },
                                    {
                                      "traitName": "explains.subType",
                                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                      "verb": {
                                        "traitName": "qualifiedBy",
                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                      }
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "has",
                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension.time",
                                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                    "IS_A": {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension"
                                    },
                                    "verb": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          },
                          "argumentValues": {
                            "dimension": "time"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "day",
                "symbol": "D",
                "dimension": "time"
              }
            },
            {
              "traitName": "has.measurement.fundamentalComponent.second",
              "explanation": "the fundamental component of time in seconds",
              "IS_A": {
                "traitName": "has.measurement.fundamentalComponent",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.dimensionKind",
                    "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                    "IS_A": {
                      "traitName": "kindOf",
                      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          }
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension.time",
                        "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                        "IS_A": {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension"
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  }
                ]
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "second",
                "symbol": "s",
                "dimension": "time",
                "fundamentalExponent": "1",
                "fundamentalScale": "86400",
                "fundamentalOffset": "0"
              }
            }
          ]
        }
      },
      "metaTraits": [
        {
          "traitName": "action.start",
          "explanation": "initiate the state or indicate the moment of being started or begun (started / completed)",
          "verb": {
            "traitName": "means",
            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
          }
        },
        {
          "traitName": "qualification.effective",
          "explanation": "active, in-place or established such as effective date or effective agreement",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "rowSelectionCriteria.maximum",
    "explanation": "(see rowSelectionCriteria) The affected attribute indicates a selected value by having the highest attribute value in the set. Example: from a group of possible records, pick the one with the greatest 'periodStartDate' value",
    "IS_A": {
      "traitName": "rowSelectionCriteria",
      "explanation": "Applied to attributes (with a 'means' or 'has' verb) to express that the attribute should be used in some way to select or disambiguate a given record from a set of other records.",
      "metaTraits": [
        {
          "traitName": "qualification.maximum",
          "explanation": "a value should be the maximum in a set (null/exists/true/false/minimum/maximum)",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The period start date for which the associated data is effective or 'as-of'."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Period Start Date"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"PeriodEndDate":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date.start.scd",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "means.measurement.date",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dayOfEra",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time.day",
          "explanation": "a measurement for duration of time in units of days",
          "IS_A": {
            "traitName": "measurement.dimension.time",
            "explanation": "measurement of time",
            "IS_A": {
              "traitName": "measurement.dimension",
              "explanation": "measurement of some physical dimension",
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            }
          },
          "metaTraits": [
            {
              "traitName": "measurement.unit.time.day",
              "explanation": "A solar day, here on earth as a measurement unit for duration of time",
              "IS_A": {
                "traitName": "measurement.unit.time",
                "explanation": "a unit of measurement for the time dimension",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "references": {
                    "traitName": "measurement.unit",
                    "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "classifications": [
                      {
                        "traitName": "measurement",
                        "references": {
                          "traitName": "measurement",
                          "explanation": "use to classify objects or other traits",
                          "verb": {
                            "traitName": "classifiedAs",
                            "references": {
                              "traitName": "classifiedAs",
                              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                            }
                          }
                        },
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      }
                    ],
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension",
                        "explanation": "measurement of some physical dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "measurement.unitKind",
                      "IS_A": {
                        "traitName": "kindOf",
                        "IS_A": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "metaTraits": [
                          {
                            "traitName": "measurement.unit",
                            "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                            "verb": {
                              "traitName": "of",
                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimension",
                                "explanation": "measurement of some physical dimension",
                                "verb": {
                                  "traitName": "of",
                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                }
                              }
                            ]
                          },
                          {
                            "traitName": "explains.subType",
                            "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                            "verb": {
                              "traitName": "qualifiedBy",
                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                            }
                          }
                        ]
                      },
                      "verb": {
                        "traitName": "has",
                        "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.dimension.time",
                          "explanation": "measurement of time",
                          "IS_A": {
                            "traitName": "measurement.dimension",
                            "explanation": "measurement of some physical dimension",
                            "metaTraits": [
                              {
                                "traitName": "measurement.dimensionKind",
                                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                                "IS_A": {
                                  "traitName": "kindOf",
                                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                  "IS_A": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension",
                                      "verb": {
                                        "traitName": "of",
                                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                      }
                                    },
                                    {
                                      "traitName": "explains.subType",
                                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                      "verb": {
                                        "traitName": "qualifiedBy",
                                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                      }
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "has",
                                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension.time",
                                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                    "IS_A": {
                                      "traitName": "dimension",
                                      "explanation": "the concept of a measurable dimension"
                                    },
                                    "verb": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          },
                          "argumentValues": {
                            "dimension": "time"
                          }
                        }
                      ]
                    }
                  ]
                }
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "day",
                "symbol": "D",
                "dimension": "time"
              }
            },
            {
              "traitName": "has.measurement.fundamentalComponent.second",
              "explanation": "the fundamental component of time in seconds",
              "IS_A": {
                "traitName": "has.measurement.fundamentalComponent",
                "IS_A": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.dimensionKind",
                    "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                    "IS_A": {
                      "traitName": "kindOf",
                      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          }
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension.time",
                        "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                        "IS_A": {
                          "traitName": "dimension",
                          "explanation": "the concept of a measurable dimension"
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  }
                ]
              },
              "verb": {
                "traitName": "has",
                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
              },
              "argumentValues": {
                "unit": "second",
                "symbol": "s",
                "dimension": "time",
                "fundamentalExponent": "1",
                "fundamentalScale": "86400",
                "fundamentalOffset": "0"
              }
            }
          ]
        }
      },
      "metaTraits": [
        {
          "traitName": "action.start",
          "explanation": "initiate the state or indicate the moment of being started or begun (started / completed)",
          "verb": {
            "traitName": "means",
            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
          }
        },
        {
          "traitName": "qualification.effective",
          "explanation": "active, in-place or established such as effective date or effective agreement",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The period end date for which the associated data is effective or 'as-of'."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Period End Date"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"MaritalStatusId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "identity.entityId",
    "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
    "IS_A": {
      "traitName": "identity.global",
      "explanation": "a number, uuid or string used to identify something globally",
      "IS_A": {
        "traitName": "means.identity",
        "explanation": "some form of identifying information"
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "entityRecord",
              "explanation": "the concept of an individual record of data that is an instance of an entityType",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              }
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "person.maritalStatusKind",
        "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
        "IS_A": {
          "traitName": "kindOf",
          "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
          "IS_A": {
            "traitName": "means",
            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
          },
          "metaTraits": [
            {
              "traitName": "person.maritalStatus",
              "verb": {
                "traitName": "of",
                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
              }
            },
            {
              "traitName": "explains.subType",
              "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
              "verb": {
                "traitName": "qualifiedBy",
                "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
              }
            }
          ]
        },
        "verb": {
          "traitName": "of",
          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of the Customer's Marital Status."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Marital Status ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.linkedEntity.identifier",
    "explanation": "Marks the attribute(s) that hold foreign key references to a linked (used as an attribute) entity. This attribute is added to the resolved entity to enumerate the referenced entities.",
    "IS_A": {
      "traitName": "is.linkedEntity",
      "explanation": "base for traits that are used to decorate the attributes and artifacts created by the traits on the hasFlexibleRelationshipWithEntity relationship."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "entityReferences": {
        "entityReference": {
          "entityShape": "entityGroupSet",
          "constantValues": [
            [
              "miniContact.cdm.json/MaritalStatus",
              "MaritalStatusId"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"CustomerMaritalStatusNote":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "A note, comment or additional information regarding the individual customer's marital status."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer Marital Status Note"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "2048"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"IndividualCustomer":{"entityProfile":[
  {
    "traitName": "commerce.individualCustomer",
    "explanation": "a party in the role of customer who purchase or uses products",
    "IS_A": {
      "traitName": "commerce.customer",
      "explanation": "a party in the role of customer who purchase or uses products",
      "IS_A": {
        "traitName": "commerce.party",
        "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
        "references": {
          "traitName": "commerce.party",
          "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
          "metaTraits": [
            {
              "traitName": "options.oneOf",
              "verb": {
                "traitName": "contains",
                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
              },
              "metaTraits": [
                {
                  "traitName": "commerce.individual",
                  "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                  "IS_A": {
                    "traitName": "person",
                    "references": {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName",
                              "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                              "IS_A": {
                                "traitName": "identity.completeName",
                                "IS_A": {
                                  "traitName": "identity.name",
                                  "explanation": "the words by which something is known or called",
                                  "IS_A": {
                                    "traitName": "means.identity",
                                    "explanation": "some form of identifying information"
                                  }
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "identity.identityKind",
                                    "IS_A": {
                                      "traitName": "kindOf",
                                      "IS_A": {
                                        "traitName": "means",
                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information",
                                          "verb": {
                                            "traitName": "of",
                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                          }
                                        },
                                        {
                                          "traitName": "explains.application",
                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                          "verb": {
                                            "traitName": "qualifiedBy",
                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                          }
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person"
                                      }
                                    ]
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.initials",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.firstName",
                                      "explanation": "A person's given or first name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.middleName",
                                      "explanation": "A person's middle name",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.prefix",
                                      "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastNamePrefix",
                                      "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.lastName",
                                      "explanation": "A person's surname, family name or last name.",
                                      "IS_A": {
                                        "traitName": "identity.name",
                                        "IS_A": {
                                          "traitName": "means.identity",
                                          "explanation": "some form of identifying information"
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "has",
                                              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.suffix",
                                      "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    "metaTraits": [
                      {
                        "traitName": "businessProcess",
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                },
                {
                  "traitName": "organization.entity",
                  "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  }
                }
              ]
            }
          ]
        },
        "metaTraits": [
          {
            "traitName": "action.purchase",
            "explanation": "the act of purchasing",
            "verb": {
              "traitName": "does",
              "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "commerce.product",
                "explanation": "an item and/or service (IS A oneOf[item, service])",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                },
                "metaTraits": [
                  {
                    "traitName": "options.oneOf",
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    },
                    "metaTraits": [
                      {
                        "traitName": "commerce.item",
                        "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      },
                      {
                        "traitName": "commerce.service",
                        "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      "metaTraits": [
        {
          "traitName": "commerce.partyKind.individual",
          "explanation": "indicates a individual party",
          "IS_A": {
            "traitName": "commerce.partyKind",
            "explanation": "a type indicator for kinds of parties",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "commerce.party",
                  "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "options.oneOf",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "commerce.individual",
                          "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                          "IS_A": {
                            "traitName": "person",
                            "references": {
                              "traitName": "person",
                              "verb": {
                                "traitName": "means",
                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                              },
                              "metaTraits": [
                                {
                                  "traitName": "options.anyOf",
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person.fullName",
                                      "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                      "IS_A": {
                                        "traitName": "identity.completeName",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "explanation": "the words by which something is known or called",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          }
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "identity.identityKind",
                                            "IS_A": {
                                              "traitName": "kindOf",
                                              "IS_A": {
                                                "traitName": "means",
                                                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information",
                                                  "verb": {
                                                    "traitName": "of",
                                                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                  }
                                                },
                                                {
                                                  "traitName": "explains.application",
                                                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                  "verb": {
                                                    "traitName": "qualifiedBy",
                                                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                  }
                                                }
                                              ]
                                            },
                                            "verb": {
                                              "traitName": "contains",
                                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "person"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "options.anyOf",
                                          "verb": {
                                            "traitName": "contains",
                                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person.initials",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.firstName",
                                              "explanation": "A person's given or first name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.middleName",
                                              "explanation": "A person's middle name",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.prefix",
                                              "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastNamePrefix",
                                              "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.lastName",
                                              "explanation": "A person's surname, family name or last name.",
                                              "IS_A": {
                                                "traitName": "identity.name",
                                                "IS_A": {
                                                  "traitName": "means.identity",
                                                  "explanation": "some form of identifying information"
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "identity.identityKind",
                                                    "IS_A": {
                                                      "traitName": "kindOf",
                                                      "IS_A": {
                                                        "traitName": "means",
                                                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                      },
                                                      "metaTraits": [
                                                        {
                                                          "traitName": "means.identity",
                                                          "explanation": "some form of identifying information",
                                                          "verb": {
                                                            "traitName": "of",
                                                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                          }
                                                        },
                                                        {
                                                          "traitName": "explains.application",
                                                          "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                          "verb": {
                                                            "traitName": "qualifiedBy",
                                                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                          }
                                                        }
                                                      ]
                                                    },
                                                    "verb": {
                                                      "traitName": "has",
                                                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                                    },
                                                    "metaTraits": [
                                                      {
                                                        "traitName": "person"
                                                      }
                                                    ]
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            },
                                            {
                                              "traitName": "person.suffix",
                                              "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                              "verb": {
                                                "traitName": "contains",
                                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                              }
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    {
                                      "traitName": "person.title",
                                      "explanation": "A personal or professional title",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.age",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.birthDate",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    },
                                    {
                                      "traitName": "person.ethnicity",
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      }
                                    }
                                  ]
                                }
                              ]
                            },
                            "metaTraits": [
                              {
                                "traitName": "businessProcess",
                                "verb": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                }
                              }
                            ]
                          },
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        },
                        {
                          "traitName": "organization.entity",
                          "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        }
                      ]
                    }
                  ]
                },
                {
                  "traitName": "explains.entity",
                  "explanation": "explaining that one concept or type indicator gives the 'type of thing' for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "metaTraits": [
              {
                "traitName": "commerce.individual",
                "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                "IS_A": {
                  "traitName": "person",
                  "references": {
                    "traitName": "person",
                    "metaTraits": [
                      {
                        "traitName": "options.anyOf",
                        "verb": {
                          "traitName": "contains",
                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                        },
                        "metaTraits": [
                          {
                            "traitName": "person.fullName",
                            "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                            "IS_A": {
                              "traitName": "identity.completeName",
                              "IS_A": {
                                "traitName": "identity.name",
                                "explanation": "the words by which something is known or called",
                                "IS_A": {
                                  "traitName": "means.identity",
                                  "explanation": "some form of identifying information"
                                }
                              },
                              "metaTraits": [
                                {
                                  "traitName": "identity.identityKind",
                                  "IS_A": {
                                    "traitName": "kindOf",
                                    "IS_A": {
                                      "traitName": "means",
                                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information",
                                        "verb": {
                                          "traitName": "of",
                                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                        }
                                      },
                                      {
                                        "traitName": "explains.application",
                                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                        "verb": {
                                          "traitName": "qualifiedBy",
                                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                        }
                                      }
                                    ]
                                  },
                                  "verb": {
                                    "traitName": "contains",
                                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "person"
                                    }
                                  ]
                                }
                              ]
                            },
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "options.anyOf",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "person.initials",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.firstName",
                                    "explanation": "A person's given or first name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.middleName",
                                    "explanation": "A person's middle name",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.prefix",
                                    "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastNamePrefix",
                                    "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.lastName",
                                    "explanation": "A person's surname, family name or last name.",
                                    "IS_A": {
                                      "traitName": "identity.name",
                                      "IS_A": {
                                        "traitName": "means.identity",
                                        "explanation": "some form of identifying information"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "identity.identityKind",
                                          "IS_A": {
                                            "traitName": "kindOf",
                                            "IS_A": {
                                              "traitName": "means",
                                              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                            },
                                            "metaTraits": [
                                              {
                                                "traitName": "means.identity",
                                                "explanation": "some form of identifying information",
                                                "verb": {
                                                  "traitName": "of",
                                                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                }
                                              },
                                              {
                                                "traitName": "explains.application",
                                                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                "verb": {
                                                  "traitName": "qualifiedBy",
                                                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                }
                                              }
                                            ]
                                          },
                                          "verb": {
                                            "traitName": "has",
                                            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "person"
                                            }
                                          ]
                                        }
                                      ]
                                    },
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  },
                                  {
                                    "traitName": "person.suffix",
                                    "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            "traitName": "person.title",
                            "explanation": "A personal or professional title",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.age",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.birthDate",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          },
                          {
                            "traitName": "person.ethnicity",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            }
                          }
                        ]
                      }
                    ]
                  },
                  "metaTraits": [
                    {
                      "traitName": "businessProcess",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "businessProcess",
        "references": {
          "traitName": "businessProcess",
          "verb": {
            "traitName": "means",
            "references": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "entityType",
        "references": {
          "traitName": "entityType",
          "explanation": "the concept of a CDM entity. Used to classify other traits that describe concepts commonly represented by entities. the trait for 'customer' would be classified as an 'entityType'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Individual Customer"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "An 'individual customer' is one of the two types of customers upon which the Microsoft data models focus.      'Legal entity customer' is the other.\n\nThe definition of 'customer' is of critical importance for every organization.    \n\nIt is the customer that is the focus of product planning, marketing, sales, service, reporting and analytics.    Without 'customer' there would be no need for the organization to exist since its purpose is to serve the customer and profit from that interaction.\n\nThe definition of 'customer' must be consistent with how customers exist and interact with the organization in the real world.  \n\nAn artificial or conceptual definition of 'customer' that is not consistent with these two objectives is doomed to fail because the data will not be consistent with the definition and employees will not accept concepts or terms that are not consistent with what they see, know and how they interact with customers on a working basis.\n\nMicrosoft defines 'customer' to meet these objectives.    When we look out into the real world we see two dominant types of customers:  human beings ('individual customers') and legal entities ('legal entity customers')>    \n\nIndividual customers are human beings, male and female individuals, of various ages, sex, demographics and a variety of similar dimensions that describe and define those who purchase products, good and services.    \n\nLegal entities are those legally-defined entities such as corporations, partnerships, non-profit organizations, government organizations etc. that purchase products, goods and services.\n\nThis view of 'customer' is consistent with the real world and consistent with how employees view and interact with customers.\n\nOf course, that is just the start of identifying, defining and understanding each corresponding type of 'customer'.     There is a great deal of detail, complexity and related data that can be used to define each type of customer to various levels of detail and different dimensions of information.    Microsoft implements these detailed concepts and related data via two distinct business area models that expand the coverage and complexity of each type of customer:\n\n-  INDIVIDUAL CUSTOMER Business Area Model\n-  LEGAL ENTITY CUSTOMER Business Area Model\n\nNote:\nEach of the Microsoft models - enterprise, business area or data warehouse - have a representative level of detail for the appropriate type of customer, which is a 'subset' of the total data available in the associated INDIVIDUAL CUSTOMER or LEGAL ENTITY CUSTOMER business area models..   Reference either of those models to expand the coverage or level of detail in each respective data model.\n\nThe actual customer implemented in each model depends upon the dominant use of customer for that industry.     \n\nFor example, in the pharmaceutical industry the customer is a legal entity, which represents another corporation, company, government organization etc. that purchases the pharmaceutical product and then distributes that product to the end-customer, which is an individual in a retail environment or a government-distribution scheme.    \n\nFor this example, the pharmaceutical models will have the legal entity customer represented but not the individual 'end customer' since that is represented in the appropriate retail industry models, which are a different offering.     \n\nOf course, the entire set of data available for a legal entity customer is contained in the associated LEGAL ENTITY CUSTOMER Business Area Model.   Reference the LEGAL ENTITY CUSTOMER Business Area Model to incorporate additional data that may be of relevance.\n\nIn many industries both types of customers are represented since a legal entity or individual can purchase products, goods or services and enter into contracts.    For these industries, both types of customers are represented by some of the more significant or relevant data derived from the associated LEGAL ENTITY or INDIVIDUAL CUSTOMER business area models.   These models can be used to expand the scope or level of detail in any of the enterprise, business area or data warehouse models."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"CustomerId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          },
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.linkedEntity.identifier",
    "explanation": "Marks the attribute(s) that hold foreign key references to a linked (used as an attribute) entity. This attribute is added to the resolved entity to enumerate the referenced entities.",
    "IS_A": {
      "traitName": "is.linkedEntity",
      "explanation": "base for traits that are used to decorate the attributes and artifacts created by the traits on the hasFlexibleRelationshipWithEntity relationship."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "entityReferences": {
        "entityReference": {
          "entityShape": "entityGroupSet",
          "constantValues": [
            [
              "miniContact.cdm.json/Customer",
              "CustomerId"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "means.identity.entityId",
    "explanation": "redefined older name convention of same concept (see the extended trait)",
    "IS_A": {
      "traitName": "identity.entityId",
      "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
      "IS_A": {
        "traitName": "identity.global",
        "explanation": "a number, uuid or string used to identify something globally",
        "IS_A": {
          "traitName": "means.identity",
          "explanation": "some form of identifying information"
        },
        "metaTraits": [
          {
            "traitName": "identity.identityKind",
            "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "means.identity",
                  "explanation": "some form of identifying information",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  }
                },
                {
                  "traitName": "explains.application",
                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "entityRecord",
                "explanation": "the concept of an individual record of data that is an instance of an entityType",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "commerce.customer",
        "explanation": "a party in the role of customer who purchase or uses products",
        "IS_A": {
          "traitName": "commerce.party",
          "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
          "references": {
            "traitName": "commerce.party",
            "explanation": "a contact or organization that acts as a party in a business process (IS A oneOf[contact, organization])",
            "metaTraits": [
              {
                "traitName": "options.oneOf",
                "verb": {
                  "traitName": "contains",
                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                },
                "metaTraits": [
                  {
                    "traitName": "commerce.individual",
                    "explanation": "a person in the context of business processes (IS A person[means->businessProcess])",
                    "IS_A": {
                      "traitName": "person",
                      "references": {
                        "traitName": "person",
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "metaTraits": [
                          {
                            "traitName": "options.anyOf",
                            "verb": {
                              "traitName": "contains",
                              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                            },
                            "metaTraits": [
                              {
                                "traitName": "person.fullName",
                                "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
                                "IS_A": {
                                  "traitName": "identity.completeName",
                                  "IS_A": {
                                    "traitName": "identity.name",
                                    "explanation": "the words by which something is known or called",
                                    "IS_A": {
                                      "traitName": "means.identity",
                                      "explanation": "some form of identifying information"
                                    }
                                  },
                                  "metaTraits": [
                                    {
                                      "traitName": "identity.identityKind",
                                      "IS_A": {
                                        "traitName": "kindOf",
                                        "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                        "IS_A": {
                                          "traitName": "means",
                                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                        },
                                        "metaTraits": [
                                          {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information",
                                            "verb": {
                                              "traitName": "of",
                                              "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                            }
                                          },
                                          {
                                            "traitName": "explains.application",
                                            "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                            "verb": {
                                              "traitName": "qualifiedBy",
                                              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                            }
                                          }
                                        ]
                                      },
                                      "verb": {
                                        "traitName": "contains",
                                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                      },
                                      "metaTraits": [
                                        {
                                          "traitName": "person"
                                        }
                                      ]
                                    }
                                  ]
                                },
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "options.anyOf",
                                    "verb": {
                                      "traitName": "contains",
                                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                    },
                                    "metaTraits": [
                                      {
                                        "traitName": "person.initials",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.firstName",
                                        "explanation": "A person's given or first name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.middleName",
                                        "explanation": "A person's middle name",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.prefix",
                                        "explanation": "A salutation such as a rank or honorific to place before a person's name",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastNamePrefix",
                                        "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.lastName",
                                        "explanation": "A person's surname, family name or last name.",
                                        "IS_A": {
                                          "traitName": "identity.name",
                                          "IS_A": {
                                            "traitName": "means.identity",
                                            "explanation": "some form of identifying information"
                                          },
                                          "metaTraits": [
                                            {
                                              "traitName": "identity.identityKind",
                                              "IS_A": {
                                                "traitName": "kindOf",
                                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                                "IS_A": {
                                                  "traitName": "means",
                                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                                },
                                                "metaTraits": [
                                                  {
                                                    "traitName": "means.identity",
                                                    "explanation": "some form of identifying information",
                                                    "verb": {
                                                      "traitName": "of",
                                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                                    }
                                                  },
                                                  {
                                                    "traitName": "explains.application",
                                                    "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                                                    "verb": {
                                                      "traitName": "qualifiedBy",
                                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                                    }
                                                  }
                                                ]
                                              },
                                              "verb": {
                                                "traitName": "has",
                                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                                              },
                                              "metaTraits": [
                                                {
                                                  "traitName": "person"
                                                }
                                              ]
                                            }
                                          ]
                                        },
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      },
                                      {
                                        "traitName": "person.suffix",
                                        "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
                                        "verb": {
                                          "traitName": "contains",
                                          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                        }
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "traitName": "person.title",
                                "explanation": "A personal or professional title",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.age",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.birthDate",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              },
                              {
                                "traitName": "person.ethnicity",
                                "verb": {
                                  "traitName": "contains",
                                  "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                                }
                              }
                            ]
                          }
                        ]
                      },
                      "metaTraits": [
                        {
                          "traitName": "businessProcess",
                          "verb": {
                            "traitName": "means",
                            "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    }
                  },
                  {
                    "traitName": "organization.entity",
                    "explanation": "a group, corporation, business, non-profit, agency, institution, etc",
                    "verb": {
                      "traitName": "contains",
                      "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                    }
                  }
                ]
              }
            ]
          },
          "metaTraits": [
            {
              "traitName": "action.purchase",
              "explanation": "the act of purchasing",
              "verb": {
                "traitName": "does",
                "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
              },
              "metaTraits": [
                {
                  "traitName": "commerce.product",
                  "explanation": "an item and/or service (IS A oneOf[item, service])",
                  "verb": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "options.oneOf",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      },
                      "metaTraits": [
                        {
                          "traitName": "commerce.item",
                          "explanation": "a product, part, component, material that is purchased, sold, transported, consumed.",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        },
                        {
                          "traitName": "commerce.service",
                          "explanation": "a subscription, unit of work or other value added service that is offered, sold, used",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        "verb": {
          "traitName": "of",
          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Customer."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Customer ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.schemaObjectIdentifier",
    "explanation": "The schema object has an identifier, which is a string, specified as the parameter of the trait. This allows writers to define additional identification values.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "identifier": "{0A62D879-DAD1-4E9D-A015-F7DB975C28C4}"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"IndividualCustomerName":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "person.fullName",
    "explanation": "a complete identifying name for a person (IS A completeName [contains->identityKind[means->person]]) has [parts of a name]",
    "IS_A": {
      "traitName": "identity.completeName",
      "explanation": "the complete name of something",
      "IS_A": {
        "traitName": "identity.name",
        "explanation": "the words by which something is known or called",
        "IS_A": {
          "traitName": "means.identity",
          "explanation": "some form of identifying information"
        }
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "contains",
            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
          },
          "metaTraits": [
            {
              "traitName": "person",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "options.anyOf",
                  "verb": {
                    "traitName": "contains",
                    "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                  },
                  "metaTraits": [
                    {
                      "traitName": "person.fullName"
                    },
                    {
                      "traitName": "person.title",
                      "explanation": "A personal or professional title",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "person.age",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "person.birthDate",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    },
                    {
                      "traitName": "person.ethnicity",
                      "verb": {
                        "traitName": "contains",
                        "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "options.anyOf",
        "verb": {
          "traitName": "contains",
          "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
        },
        "metaTraits": [
          {
            "traitName": "person.initials",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.firstName",
            "explanation": "A person's given or first name.",
            "IS_A": {
              "traitName": "identity.name",
              "IS_A": {
                "traitName": "means.identity",
                "explanation": "some form of identifying information"
              },
              "metaTraits": [
                {
                  "traitName": "identity.identityKind",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "means.identity",
                        "explanation": "some form of identifying information",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.application",
                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName"
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.middleName",
            "explanation": "A person's middle name",
            "IS_A": {
              "traitName": "identity.name",
              "IS_A": {
                "traitName": "means.identity",
                "explanation": "some form of identifying information"
              },
              "metaTraits": [
                {
                  "traitName": "identity.identityKind",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "means.identity",
                        "explanation": "some form of identifying information",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.application",
                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName"
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.prefix",
            "explanation": "A salutation such as a rank or honorific to place before a person's name",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.lastNamePrefix",
            "explanation": "one of the standardized, culture specific last name prefixes, such as 'Van' or 'Le'",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.lastName",
            "explanation": "A person's surname, family name or last name.",
            "IS_A": {
              "traitName": "identity.name",
              "IS_A": {
                "traitName": "means.identity",
                "explanation": "some form of identifying information"
              },
              "metaTraits": [
                {
                  "traitName": "identity.identityKind",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "means.identity",
                        "explanation": "some form of identifying information",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.application",
                        "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "person",
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "options.anyOf",
                          "verb": {
                            "traitName": "contains",
                            "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "person.fullName"
                            },
                            {
                              "traitName": "person.title",
                              "explanation": "A personal or professional title",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.age",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.birthDate",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            },
                            {
                              "traitName": "person.ethnicity",
                              "verb": {
                                "traitName": "contains",
                                "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          },
          {
            "traitName": "person.suffix",
            "explanation": "Follows a person's name and provides additional information about their position, education or honorific",
            "verb": {
              "traitName": "contains",
              "explanation": "OBJECT [contains->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) owns, contains, is made from the class specified by TRAIT. 'contains' has the inverse implications of 'of'"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The name of the Individual Customer."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Individual Customer Name"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "256"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"DateOfBirth":[
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "means.measurement.date",
    "explanation": "a measurement for duration of time in units of days",
    "IS_A": {
      "traitName": "measurement.dayOfEra",
      "explanation": "a measurement for duration of time in units of days",
      "IS_A": {
        "traitName": "measurement.dimension.time.day",
        "explanation": "a measurement for duration of time in units of days",
        "IS_A": {
          "traitName": "measurement.dimension.time",
          "explanation": "measurement of time",
          "IS_A": {
            "traitName": "measurement.dimension",
            "explanation": "measurement of some physical dimension",
            "metaTraits": [
              {
                "traitName": "measurement.dimensionKind",
                "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                "IS_A": {
                  "traitName": "kindOf",
                  "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                  "IS_A": {
                    "traitName": "means",
                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    },
                    {
                      "traitName": "explains.subType",
                      "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                      "verb": {
                        "traitName": "qualifiedBy",
                        "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                      }
                    }
                  ]
                },
                "verb": {
                  "traitName": "has",
                  "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                },
                "metaTraits": [
                  {
                    "traitName": "dimension.time",
                    "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                    "IS_A": {
                      "traitName": "dimension",
                      "explanation": "the concept of a measurable dimension"
                    },
                    "verb": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    }
                  }
                ]
              }
            ]
          }
        },
        "metaTraits": [
          {
            "traitName": "measurement.unit.time.day",
            "explanation": "A solar day, here on earth as a measurement unit for duration of time",
            "IS_A": {
              "traitName": "measurement.unit.time",
              "explanation": "a unit of measurement for the time dimension",
              "IS_A": {
                "traitName": "measurement.unit",
                "references": {
                  "traitName": "measurement.unit",
                  "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "classifications": [
                    {
                      "traitName": "measurement",
                      "references": {
                        "traitName": "measurement",
                        "explanation": "use to classify objects or other traits",
                        "verb": {
                          "traitName": "classifiedAs",
                          "references": {
                            "traitName": "classifiedAs",
                            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                          }
                        }
                      },
                      "verb": {
                        "traitName": "classifiedAs",
                        "references": {
                          "traitName": "classifiedAs",
                          "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                        }
                      }
                    }
                  ],
                  "metaTraits": [
                    {
                      "traitName": "measurement.dimension",
                      "explanation": "measurement of some physical dimension",
                      "verb": {
                        "traitName": "of",
                        "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                      }
                    }
                  ]
                },
                "metaTraits": [
                  {
                    "traitName": "measurement.unitKind",
                    "IS_A": {
                      "traitName": "kindOf",
                      "IS_A": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      },
                      "metaTraits": [
                        {
                          "traitName": "measurement.unit",
                          "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                          "verb": {
                            "traitName": "of",
                            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                          },
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimension",
                              "explanation": "measurement of some physical dimension",
                              "verb": {
                                "traitName": "of",
                                "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                              }
                            }
                          ]
                        },
                        {
                          "traitName": "explains.subType",
                          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                          "verb": {
                            "traitName": "qualifiedBy",
                            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                          }
                        }
                      ]
                    },
                    "verb": {
                      "traitName": "has",
                      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                    },
                    "metaTraits": [
                      {
                        "traitName": "measurement.dimension.time",
                        "explanation": "measurement of time",
                        "IS_A": {
                          "traitName": "measurement.dimension",
                          "explanation": "measurement of some physical dimension",
                          "metaTraits": [
                            {
                              "traitName": "measurement.dimensionKind",
                              "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                              "IS_A": {
                                "traitName": "kindOf",
                                "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                                "IS_A": {
                                  "traitName": "means",
                                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                },
                                "metaTraits": [
                                  {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension",
                                    "verb": {
                                      "traitName": "of",
                                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                                    }
                                  },
                                  {
                                    "traitName": "explains.subType",
                                    "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                                    "verb": {
                                      "traitName": "qualifiedBy",
                                      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                                    }
                                  }
                                ]
                              },
                              "verb": {
                                "traitName": "has",
                                "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                              },
                              "metaTraits": [
                                {
                                  "traitName": "dimension.time",
                                  "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                                  "IS_A": {
                                    "traitName": "dimension",
                                    "explanation": "the concept of a measurable dimension"
                                  },
                                  "verb": {
                                    "traitName": "means",
                                    "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        "verb": {
                          "traitName": "means",
                          "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                        },
                        "argumentValues": {
                          "dimension": "time"
                        }
                      }
                    ]
                  }
                ]
              }
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "day",
              "symbol": "D",
              "dimension": "time"
            }
          },
          {
            "traitName": "has.measurement.fundamentalComponent.second",
            "explanation": "the fundamental component of time in seconds",
            "IS_A": {
              "traitName": "has.measurement.fundamentalComponent",
              "IS_A": {
                "traitName": "measurement.unit",
                "explanation": "description of 'units' (expressed with 'symbol') used to measure some quantity along a 'dimension'",
                "metaTraits": [
                  {
                    "traitName": "measurement.dimension",
                    "explanation": "measurement of some physical dimension",
                    "verb": {
                      "traitName": "of",
                      "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                    }
                  }
                ]
              },
              "metaTraits": [
                {
                  "traitName": "measurement.dimensionKind",
                  "explanation": "a type indicator for kind of a dimension, AKA capacitance, time, distance.",
                  "IS_A": {
                    "traitName": "kindOf",
                    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
                    "IS_A": {
                      "traitName": "means",
                      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                    },
                    "metaTraits": [
                      {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension",
                        "verb": {
                          "traitName": "of",
                          "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                        }
                      },
                      {
                        "traitName": "explains.subType",
                        "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
                        "verb": {
                          "traitName": "qualifiedBy",
                          "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                        }
                      }
                    ]
                  },
                  "verb": {
                    "traitName": "has",
                    "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
                  },
                  "metaTraits": [
                    {
                      "traitName": "dimension.time",
                      "explanation": "the concept of 'time' used to describe other concepts such as the measurement of 'time'",
                      "IS_A": {
                        "traitName": "dimension",
                        "explanation": "the concept of a measurable dimension"
                      },
                      "verb": {
                        "traitName": "means",
                        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                      }
                    }
                  ]
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "argumentValues": {
              "unit": "second",
              "symbol": "s",
              "dimension": "time",
              "fundamentalExponent": "1",
              "fundamentalScale": "86400",
              "fundamentalOffset": "0"
            }
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "argumentValues": {
      "dimension": "time"
    },
    "classifications": [
      {
        "traitName": "measurement",
        "references": {
          "traitName": "measurement",
          "explanation": "use to classify objects or other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The date of birth of the individual customer."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Date Of Birth"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.date",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"Party":{"entityProfile":[
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "Party/(resolvedAttributes)/PartyId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Party"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "A party is an individual, organization, legal entity, social organization or business unit of interest to the business.\n\nParty is a concept that enables individuals, organizations, legal entities, social organization and business units to be related or defined with the context of roles, events and relationships.\n\nThis enables us to 'anchor' disparate instances or implementations of each of the above to a common or singular instance of that individual, organization, legal entity, social organization or business unit.\n\nFor example, a large business has 20 customer masters that are used internally.    PARTY enables the organization to identify and define each customer as a single party and relate (cleanse and synchronize) the multiple instances of customer to a single set of customer information.\n\nIt also allows the business to look at the multiple relationships that exist among parties playing different roles over various periods of time.    \n\nFor example, a business might have a vendor who is also a customer that has employees who are also customers of the business.     A business might have employees who are also customers and whose spouse or family members are also customers.\n\nIn short, party enables the business to examine and record the real-world interactions of individuals, organizations, legal entities, social organizations and business units as they perform those many roles that characterize their activities and relationships to other parties.      Party also provides an 'anchor' upon which to resolve multiple instances or definitions of that party so the business can develop a 'single-view' of the party."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"PartyId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          },
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "Party/(resolvedAttributes)/PartyId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "means.identity.entityId",
    "explanation": "redefined older name convention of same concept (see the extended trait)",
    "IS_A": {
      "traitName": "identity.entityId",
      "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
      "IS_A": {
        "traitName": "identity.global",
        "explanation": "a number, uuid or string used to identify something globally",
        "IS_A": {
          "traitName": "means.identity",
          "explanation": "some form of identifying information"
        },
        "metaTraits": [
          {
            "traitName": "identity.identityKind",
            "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
            "IS_A": {
              "traitName": "kindOf",
              "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
              "IS_A": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              },
              "metaTraits": [
                {
                  "traitName": "means.identity",
                  "explanation": "some form of identifying information",
                  "verb": {
                    "traitName": "of",
                    "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                  }
                },
                {
                  "traitName": "explains.application",
                  "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                  "verb": {
                    "traitName": "qualifiedBy",
                    "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                  }
                }
              ]
            },
            "verb": {
              "traitName": "has",
              "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
            },
            "metaTraits": [
              {
                "traitName": "entityRecord",
                "explanation": "the concept of an individual record of data that is an instance of an entityType",
                "verb": {
                  "traitName": "means",
                  "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
                }
              }
            ]
          }
        ]
      }
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Party."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Party ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"PartyName":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The name of the Party."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Party Name"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "256"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"GlobalLocationNumber":[
  {
    "traitName": "is.dataFormat.numeric.shaped",
    "explanation": "for setting the exact precision and scale of numeric values",
    "IS_A": {
      "traitName": "is.dataFormat.numeric",
      "IS_A": {
        "traitName": "is.dataFormat"
      }
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The Global Location Number (GLN) is a simple tool used to uniquely identify locations. It can be used to identify physical locations such as a warehouse, legal entities, or a function / department within a legal entity. The GLN is part of the GS1 system of standards."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Global Location Number (GLN)"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.numeric.shaped",
    "explanation": "for setting the exact precision and scale of numeric values",
    "IS_A": {
      "traitName": "is.dataFormat.numeric",
      "IS_A": {
        "traitName": "is.dataFormat"
      }
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"Gender":{"entityProfile":[
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "Gender/(resolvedAttributes)/GenderId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "person.genderKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.gender",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Gender"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The social roles based on the sex of the person (culturally learned) or personal identification of one's own gender based on an internal awareness (gender identity).\n\nEx.:\n- Male\n- Female\n- Transgender\n- Agender\n- Androgyne\n- Androgynous\n- Bigender\n- Cis\n- Cisgender\n- Cis Female\n- Cis Male\n- Cis Man\n- Cis Woman\n- Cisgender Female\n- Cisgender Male\n- Cisgender Man\n- Cisgender Woman\n- Female to Male\n- FTM\n- Gender Fluid\n- Gender Nonconforming\n- Gender Questioning\n- Gender Variant\n- Genderqueer\n- Intersex\n- Male to Female\n- MTF\n- Neither\n- Neutrois\n- Non-binary\n- Other\n- Pangender\n- Trans\n- Trans*\n- Trans Female\n- Trans* Female\n- Trans Male\n- Trans* Male\n- Trans Man\n- Trans* Man\n- Trans Person\n- Trans* Person\n- Trans Woman\n- Trans* Woman\n- Transfeminine\n- Transgender Female\n- Transgender Male\n- Transgender Man\n- Transgender Person\n- Transgender Woman\n- Transmasculine\n- Transsexual\n- Transsexual Female\n- Transsexual Male\n- Transsexual Man\n- Transsexual Person\n- Transsexual Woman\n- Two-Spirit"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"GenderId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "Gender/(resolvedAttributes)/GenderId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "identity.entityId",
    "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
    "IS_A": {
      "traitName": "identity.global",
      "explanation": "a number, uuid or string used to identify something globally",
      "IS_A": {
        "traitName": "means.identity",
        "explanation": "some form of identifying information"
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "entityRecord",
              "explanation": "the concept of an individual record of data that is an instance of an entityType",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              }
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of a Gender."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Gender ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"GenderName":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "person.genderKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.gender",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "constrainedList.kindOfMapping",
        "explanation": "The values of an attribute can be mapped (using the values in this table) into a standard set of 'kindOf' trait references",
        "verb": {
          "traitName": "has",
          "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
        },
        "argumentValues": {
          "defaultList": {
            "entityReference": {
              "explanation": "The constantValues below correspond to the attributes of the 'listLookupKindOfMapping' entityShape which are: {attributeValue, traitPath}",
              "entityShape": "listLookupKindOfMapping",
              "constantValues": [
                [
                  "Female",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.female"
                ],
                [
                  "Male",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.male"
                ],
                [
                  "Other",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.other"
                ],
                [
                  "Unknown",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.unknown"
                ],
                [
                  "",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.unknown"
                ],
                [
                  "Unspecified",
                  "cdm:/cdmfoundation/meanings.demographics.cdm.json/person.genderKind.unspecified"
                ]
              ]
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The name of the Gender."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Gender Name"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "256"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"GenderDescription":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The description of the Gender."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Gender Description"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "2048"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}},"MaritalStatus":{"entityProfile":[
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "MaritalStatus/(resolvedAttributes)/MaritalStatusId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "person.maritalStatusKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.maritalStatus",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Marital Status"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The marital status of an individual.\n\nThe US Bureau of Census identifies four major categories: \n\n-  never married\n-  married\n-  widowed\n-  divorced \n\nThe category \"married\" is further divided into \"married, spouse present,\" \"separated,\" and \"other married, spouse absent.\" A person was classified as \"married, spouse present\" if the husband or wife was reported as a member of the household, even though he or she may have been temporarily absent on business or on vacation, visiting, in a hospital, etc., at the time of the enumeration. People reported as separated included those with legal separations, those living apart with intentions of obtaining a divorce, and other people permanently or temporarily separated because of marital discord. The group \"other married, spouse absent\" includes married people living apart because either the husband or wife was employed and living at a considerable distance from home, was serving away from home in the Armed Forces, had moved to another area, or had a different place of residence for any other reason except separation as defined above.\n\nNEVER MARRIED\nIncludes all persons who have never been married, including persons whose only marriage(s) was annulled. \n\nMARRIED\nMarried is a status for those who on the enumeration date were bound by marriage, regardless of whether they are living together or not. This includes those who by law (e.g. tradition, religion, state, etc.) are formally married but also those who live together and are regarded by their community as husbands and wives.\n\nWIDOWED\nWidowed is a status for those whose husbands or wives were deceased and had not yet remarried.\n\nDIVORCED\nRefers to a category for those who divorced their husbands or wives and have not yet remarried.\n\nSEPARATED\nIncludes persons legally separated or otherwise absent from their spouse because of marital discord. Included are persons who have been deserted or who have parted because they no longer want to live together but who have not obtained a divorce. \n\nNOW MARRIED/EXCEPT SEPARATED\nIncludes persons whose current marriage has not ended through widowhood, divorce, or separation (regardless of previous marital history). The category may also include couples who live together or persons in common-law marriages if they consider this category the most appropriate. In certain tabulations, currently married persons are further classified as \"spouse present\" or \"spouse absent.\" \n\nUNMARRIED COUPLE\nA couple that is not married but are living together.\n\nCOMMON-LAW MARRIAGE\nA common law marriage comes about when a man and woman who are free to marry agree to live together as husband and wife without the formal ceremony. In order to be common law married, both spouses must have intended to be husband and wife. Certain states do not recognize common law marriages."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "has.entitySchemaAbstractionLevel",
    "explanation": "A level of abstraction assigned to an Entity schema. Logical schema descriptions use complex dataTypes, inheritance, and entities as attributes. Resolved descriptions contain none of those things, only final trait and attribute sets are shown. A composition schema manipulates, guides or re-states parts of logical schemas to produce one resolved schema.",
    "IS_A": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "level": "resolved"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
], "attProfiles":{"MaritalStatusId":[
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.signed",
    "explanation": "indicates the capability to represent values less than zero.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.numeric",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.integer",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.signed",
            "explanation": "indicates the capability to represent values less than zero.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.identifiedBy",
    "explanation": "names a specifc identity attribute to use with an entity",
    "IS_A": {
      "traitName": "does.elevateAttribute",
      "explanation": "elevates (up to a entity) a trait that describes a specific attribute",
      "IS_A": {
        "traitName": "does",
        "explanation": "OBJECT [does->TRAIT] asserts that OBJECT performs the action indicated by TRAIT."
      }
    },
    "verb": {
      "traitName": "meta",
      "explanation": "a trait used as the verb for other traits that are only used as verbs or other internal indicators of meta meaning"
    },
    "argumentValues": {
      "attribute": "MaritalStatus/(resolvedAttributes)/MaritalStatusId"
    },
    "classifications": [
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "identity.entityId",
    "explanation": "A value that uniquely identifies an instance (record) of some entity (IS A identity.global[has->identityKind[means->entityRecord]])",
    "IS_A": {
      "traitName": "identity.global",
      "explanation": "a number, uuid or string used to identify something globally",
      "IS_A": {
        "traitName": "means.identity",
        "explanation": "some form of identifying information"
      },
      "metaTraits": [
        {
          "traitName": "identity.identityKind",
          "explanation": "explains the type of an identity (entity id, person name, product number) (IS A kindOf[of->identification])",
          "IS_A": {
            "traitName": "kindOf",
            "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
            "IS_A": {
              "traitName": "means",
              "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
            },
            "metaTraits": [
              {
                "traitName": "means.identity",
                "explanation": "some form of identifying information",
                "verb": {
                  "traitName": "of",
                  "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
                }
              },
              {
                "traitName": "explains.application",
                "explanation": "explaining that one concept or type indicator gives a usage or application for another concept",
                "verb": {
                  "traitName": "qualifiedBy",
                  "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
                }
              }
            ]
          },
          "verb": {
            "traitName": "has",
            "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
          },
          "metaTraits": [
            {
              "traitName": "entityRecord",
              "explanation": "the concept of an individual record of data that is an instance of an entityType",
              "verb": {
                "traitName": "means",
                "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
              }
            }
          ]
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "identification",
        "references": {
          "traitName": "identification",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The unique identifier of the Marital Status."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Marital Status ID"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.dataFormat.integer",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"MaritalStatusName":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "person.maritalStatusKind",
    "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
    "IS_A": {
      "traitName": "kindOf",
      "explanation": "A specialization of the 'means' verb to use in a 'non-verb' way like for the meaning, classification or application of an object that describe the 'kind of' or 'type of' another object. This is semantically equivalent to the 'means' verb but it helps avoid a super mind bending problem. For example, a phoneNumberType column contains words like 'mobile'. So, the values in the domain of the column tells you the semantic type of a phone number. The trait 'means' indicates this exact concept (used to name the semantic type of another thing)  and so one should ascribe that trait to the phoneNumberType column ... using the 'means' verb. Oh no! That would be phoneNumberType means means phoneNumber. I wrote this and I can't follow it. If we just swap in the words 'kindOf' to use as the semantic type we get phoneNumberType means kindOf phoneNumber. To be more precise, it would be kindOf[of->phoneNumber] since the kind is a property of the phone number. I think that makes total sense. This trait can also get used with a 'has' verb to attach a specific type onto an object. For instance, the mobilePhoneNumber column 'means' phoneNumber but 'has' kindOf[of->phoneNumber, means->mobile]. An even more abstract case is a boolean typed column called isThisAMobilePhoneNumber because it contains values from the domain of kindOf[of->phoneNumber, means->mobile] (right? the domain of that trait is only 'yes it is' or 'no it isn't') therefore we would say isThisAMobilePhoneNumber means->kindOf [of->phoneNumber, means->mobile]. As you can see, this kind of kindOf trait kind of helps with understanding the non-verb uses of the 'means' trait, even though in truth it means means means.",
      "IS_A": {
        "traitName": "means",
        "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
      },
      "metaTraits": [
        {
          "traitName": "person.maritalStatus",
          "verb": {
            "traitName": "of",
            "explanation": "('of' is not a verb but 'is belonging to' is awkward) OBJECT [of->TRAIT] asserts that OBJECT (most likely a trait) is a part of, belongs to, comes from, is for TRAIT. 'address'[of->'customer'] for example. 'of' has the inverse implications of 'contains'"
          }
        },
        {
          "traitName": "explains.subType",
          "explanation": "explaining that one concept or type indicator gives a subType or specialization for another concept",
          "verb": {
            "traitName": "qualifiedBy",
            "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
          }
        }
      ]
    },
    "verb": {
      "traitName": "means",
      "explanation": "OBJECT [means->TRAIT] asserts that the data values from OBJECT (entity records, attribute values, trait domain) have the semantic meaning specified by TRAIT. If an entity 'means' 'contract' then the records in that entity represent contract. If an attribute 'means' phoneNumber, then the values for that attribute in the entity records should contain phone numbers. If trait1 'means' trait2, it indicates a 'specialization' (see kindOf for more details) "
    },
    "classifications": [
      {
        "traitName": "demographic",
        "references": {
          "traitName": "demographic",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        },
        "verb": {
          "traitName": "classifiedAs",
          "references": {
            "traitName": "classifiedAs",
            "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "fundamental",
        "references": {
          "traitName": "fundamental",
          "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      },
      {
        "traitName": "verb",
        "references": {
          "traitName": "verb",
          "explanation": "a trait used to classify the special 'verb' traits explain how other traits are being applied or used or related",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          },
          "classifications": [
            {
              "traitName": "fundamental",
              "references": {
                "traitName": "fundamental",
                "explanation": "a trait used to classify other traits that are 'fundamental' to the operation of the system, AKA 'internal use'",
                "verb": {
                  "traitName": "classifiedAs",
                  "references": {
                    "traitName": "classifiedAs",
                    "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
                  }
                }
              }
            }
          ]
        }
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The name of the Marital Status."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Marital Status Name"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "256"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
],"MaritalStatusDescription":[
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.big",
    "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "qualifiedBy",
      "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ],
    "metaTraits": [
      {
        "traitName": "is.dataFormat.character",
        "IS_A": {
          "traitName": "is.dataFormat"
        },
        "verb": {
          "traitName": "is",
          "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
        },
        "metaTraits": [
          {
            "traitName": "is.dataFormat.big",
            "explanation": "indicates an atomic but multi-unit version of a fundamental type such as a multi byte encoded character, a double precision float, a long integer.",
            "IS_A": {
              "traitName": "is.dataFormat"
            },
            "verb": {
              "traitName": "qualifiedBy",
              "explanation": "OBJECT [qualifiedBy->TRAIT] asserts that OBJECT is given the quality described by TRAIT. Note this relationship is different from 'of' and 'means' in that qualifiedBy is used to ascribe characteristics, not ownership or specialization. In 'date' [qualifiedBy->'estimate'] for example a date is not 'part of' estimate nor is estimateDate a specialization of date"
            }
          }
        ]
      }
    ]
  },
  {
    "traitName": "is.localized.describedAs",
    "explanation": "Holds the list of language specific descriptive text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "The description of the Marital Status."
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.nullable",
    "explanation": "The attribute value may be set to NULL.",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    }
  },
  {
    "traitName": "is.localized.displayedAs",
    "explanation": "Holds the list of language specific display text for an object.",
    "IS_A": {
      "traitName": "is.localized",
      "explanation": "Associates a list of localized string with an object"
    },
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "localizedDisplayText": {
        "entityReference": {
          "entityShape": "localizedTable",
          "constantValues": [
            [
              "en",
              "Marital Status Description"
            ]
          ]
        }
      }
    }
  },
  {
    "traitName": "is.constrained",
    "explanation": "maximum length or value constraints",
    "verb": {
      "traitName": "has",
      "explanation": "OBJECT [has->TRAIT] asserts that the class of OBJECT (entity definition, attribute specification, trait) has attached to it the class specified by TRAIT."
    },
    "argumentValues": {
      "maximumLength": "2048"
    }
  },
  {
    "traitName": "is.dataFormat.character",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  },
  {
    "traitName": "is.dataFormat.array",
    "explanation": "indicates a contiguous sequence of fundamental units that shoud be taken as a whole and considered one value. Array of Character is a String, Array of Byte is a Binary Object",
    "IS_A": {
      "traitName": "is.dataFormat"
    },
    "verb": {
      "traitName": "is",
      "explanation": "OBJECT [is->TRAIT] asserts that the data values from OBJECT (entity records, attribute values) take the form specified by TRAIT. Generally used for data formats or other structural guidance"
    },
    "classifications": [
      {
        "traitName": "dataFormat",
        "references": {
          "traitName": "dataFormat",
          "explanation": "the idea of a data format, used to classify or explain other traits",
          "verb": {
            "traitName": "classifiedAs",
            "references": {
              "traitName": "classifiedAs",
              "explanation": "OBJECT [classifiedAs->TRAIT] asserts that OBJECT falls into the category described by TRAIT. Note that one OBJECT can have many 'classifiedAs' TRAITS ascribed to it."
            }
          }
        }
      }
    ]
  }
]}}}